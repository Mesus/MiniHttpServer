        		<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='zh-CN' xml:lang='zh-CN' xmlns='http://www.w3.org/1999/xhtml'>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta http-equiv="Content-Language" content="zh-CN"/>
  <title>tmj的博客</title>
  <style>
  body {font:12px/21px Tahoma,"Microsoft Yahei",Geneva,sans-serif;}
  h1 a {color:#40AA53;}
  h1 a,h2 a{text-decoration:none;}
  .backupDesc em {font-style:normal;}
  .blog {margin:0 0 20px 0;border:1px solid #ccc;background:#ffc;padding:10px;}
  .blog h2 {border-bottom:1px solid #ccc;padding:0 0 10px 0;}
  .blog h2 a.top {float:right;font-weight:normal;font-size:9pt;}
  .blog .outline {background:#fff;border:1px solid #eee;padding:10px;color:#666;}
  
  .commentList {margin:20px 0 0 0;}
  .comment {margin:0 0 10px 0; border:1px solid #ddd; background:#ffe;padding:5px;}
  .comment .author {float:left;font-weight:bold;}
  .comment .date {float:left;margin:0 0 0 10px;}
  .comment .content {clear:left;margin:5px 0 0 0;}
  </style>
</head>
<body>
  <h1><a name='top' href="http://my.oschina.net/tmj1993/blog">tmj的博客@OSCHINA</a></h1>
  <p class='backupDesc'>共有<em>14</em>篇文章，备份时间：2015-11-01 21:52:53</p>
  <ol>
		<li><a href="#blog_524664">daocloud中构建一个hallo docker网页服务器的docker镜像并部署</a></li>
		<li><a href="#blog_504407">virtualbox虚拟化硬件加速不可用，virtualbox到hyper转移</a></li>
		<li><a href="#blog_500951">C-BlogServer博客-数据库以及验证码的解决</a></li>
		<li><a href="#blog_500909">Python-BlogServer博客-Django博客效果</a></li>
		<li><a href="#blog_500342">C-BlogServer博客-基于Django的wsgi接口多线程C服务器</a></li>
		<li><a href="#blog_500171">Python-BlogServer博客-C调用Python的wsgi接口</a></li>
		<li><a href="#blog_495645">C-BlogServer博客-可并发的http服务器</a></li>
		<li><a href="#blog_494686">C#-JudgeSystem判题系统-开放实验总结</a></li>
		<li><a href="#blog_494684">C#-JudgeSystem判题系统-判题系统</a></li>
		<li><a href="#blog_494677">C#-JudgeSystem判题系统-C#编译C程序</a></li>
		<li><a href="#blog_494667">C#-JudgeSystem判题系统-客户端和多线程</a></li>
		<li><a href="#blog_494573">C#-JudgeSystem判题系统-一个简单的HTTPServer</a></li>
		<li><a href="#blog_494519">C#-JudgeSystem判题系统-安装和熟悉C#开发环境</a></li>
		<li><a href="#blog_494496">开始博客之旅</a></li>
	  </ol>
  <div class='blogList'>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_524664" href="http://my.oschina.net/tmj1993/blog/524664">daocloud中构建一个hallo docker网页服务器的docker镜像并部署</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-11-01 21:48:15</div>
	  <div class='catalog'>分类：Docker应用容器</div>
	  	  	  <div class='tags'>标签：docker,daocloud</div>	  	  	  </div>
      <div class='content'><p>最近刚接触了一两天的docker，个人对docker的理解就是</p><p>对于用户是一个虚拟机</p><p>对于运营商而言这个虚拟机带来的资源消耗比传统的虚拟机要少得多</p><p>实话说我就是用户罢了，不考虑这么多，就看怎么用这虚拟机而已</p><p>如果拿来做一个网站服务器，相对与sae那种方式而已，docker的可操作性更大，更加灵活，就好像我能用C语言去做一个网站服务器，比较虚拟机比起空间啥的还是方便很多的，简直有无限大的潜力，不知道能不能达到vps的自由度</p><p>当然docker还不止这点好处，一个镜像就相当于一个应用，就好像安卓一样，换一台手机，只要下载回我的应用部署一下就能够启动服务了，是不是很简单，不用在去重复弄一堆麻烦的指令操作，所有的东西打包成一个应用，比方说，就是一个按钮，wordpress就可以用了，啥都不用做！！就好像直接拿别人的虚拟机过来用，就是这么简单</p><p>ok~说了下理解的东西，立马试一下这玩意到底怎么用，在用的过程体会一下docker的魅力</p><p>先说一下流程吧，不弄一堆麻烦的，只要没用过谁也看不懂的框架，就用c语言的一个http服务器</p><p>之前博客里写的<a href="http://my.oschina.net/tmj1993/blog/495645" rel="nofollow">http://my.oschina.net/tmj1993/blog/495645</a> </p><p>待会就用这么作为docker的核心内容<br></p><p>先登录daocloud</p><p><img src="http://static.oschina.net/uploads/space/2015/1101/212600_d9ck_1469400.png"></p><p>创建新项目</p><p>连上我的github，然后指定我自己github上面的项目，是刚刚早上push上去的<br></p><p><a href="https://github.com/ahelloworld/MiniHttpServer" rel="nofollow">https://github.com/ahelloworld/MiniHttpServer</a> </p><p>ok，里面就三个文件</p><p>一个是源文件<a href="https://github.com/ahelloworld/MiniHttpServer/blob/master/httpserver.c" rel="nofollow">httpserver.c</a></p><p>一个是makefile文件，将源文件通过make all，得到httpserver可运行文件</p><p>一个是dockerfile文件，这个文件就是应用打包的关键拉</p><p><span style="box-sizing: border-box; color: rgb(167, 29, 93); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">FROM</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"> ubuntu&nbsp;&nbsp;&nbsp;&nbsp;//相当安装一个ubuntu核心系统</span></p><p><span style="box-sizing: border-box; color: rgb(167, 29, 93); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">MAINTAINER</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"> ahelloworld &lt;tmj1165818439.tm@gmail.com&gt;&nbsp;&nbsp;&nbsp;&nbsp;//没啥用，说一下个人信息罢了</span></p><p><span style="box-sizing: border-box; color: rgb(167, 29, 93); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">RUN</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"> apt-get update&nbsp;&nbsp;&nbsp;&nbsp;//更新</span></p><p><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; color: rgb(167, 29, 93); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">RUN</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"> apt-get -y install gcc make&nbsp;&nbsp;&nbsp;&nbsp;//安装一下gcc和make，因为这个系统只有核心部分</span></span></p><p><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; color: rgb(167, 29, 93); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">COPY</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"> / /&nbsp;&nbsp;&nbsp;&nbsp;//将我github的根目录拷贝到虚拟机根目录</span></span></span></p><p><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; color: rgb(167, 29, 93); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">EXPOSE</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"> 80&nbsp;&nbsp;&nbsp;&nbsp;//开放80端口</span></span></span></span></p><p><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; color: rgb(167, 29, 93); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">RUN</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"> make all&nbsp;&nbsp;&nbsp;&nbsp;//复制完了自然是对根目录下的httpserver.c文件进行编译拉，通过makefile编译一下，得到一个<span style="color: rgb(24, 54, 145); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">httpserver</span>可运行文件</span></span></span></span></span></p><p><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; color: rgb(167, 29, 93); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">ENTRYPOINT</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);"> [</span><span style="box-sizing: border-box; color: rgb(24, 54, 145); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">"/httpserver"</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">, </span><span style="box-sizing: border-box; color: rgb(24, 54, 145); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">"80"</span><span style="color: rgb(51, 51, 51); font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 12px; line-height: 16.8px; white-space: pre; background-color: rgb(255, 255, 255);">]&nbsp;&nbsp;&nbsp;&nbsp;//可运行文件运行咯</span></span></span></span></span></span></p><p>ok！</p><p>我们看看这个镜像的制作过程</p><p><img src="http://static.oschina.net/uploads/space/2015/1101/213602_nJay_1469400.png"></p><p><br></p><p>部署的时间也是挺快的哈，第一步先从cache查找，第二步就是我github的源文件clone拉</p><p>第三步镜像的制作，可以展开看一些细节，有些操作重复的可能会做成cache，然后别人做相同操作就可以从cache获取加快速度，云计算大数据啥的？反正用得人很多数据库非常大的情况下也许会非常好</p><p>到了entrypoint那一步就是程序的运行(cmd也类似)，前面制作完镜像了，在镜像的条件下，我们通过./httpserver 80来用这么镜像提供网页服务拉，cmd的话提供可改变运行参数的方式，entrypoint采用固定的方式，因为只开了80端口，就算提供可变也是没啥用，还是entrypoint走起</p><p>最后镜像就做出来了</p><p><img src="http://static.oschina.net/uploads/space/2015/1101/214307_z0V5_1469400.png"></p><p>镜像有了就可以随意部署了，就像类与对象的关系，就像商城应用与你手机上的应用的关系，做出一个镜像，就可以供大家部署使用</p><p>部署就没啥好说的啦，按两下的事<br></p><p><a href="http://hellodocker-minihttp.daoapp.io/" rel="nofollow">http://hellodocker-minihttp.daoapp.io/</a> </p><p>提供一个网址给大家看看效果，不定期失效，因为这个应用会占用我一个额度呀，估计过一段时间就关了</p><p><img src="http://static.oschina.net/uploads/space/2015/1101/214657_FkV6_1469400.png"></p><p>就是hello docker呗</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_504407" href="http://my.oschina.net/tmj1993/blog/504407">virtualbox虚拟化硬件加速不可用，virtualbox到hyper转移</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-09-10 13:42:05</div>
	  <div class='catalog'>分类：维护</div>
	  	  	  	  	  </div>
      <div class='content'><p>问题：在设置-系统-硬件加速灰色不可选</p>  <p><a href="http://static.oschina.net/uploads/img/201509/10134039_2MGD.png"><img title="Unnamed QQ Screenshot20150910131852" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150910131852" src="http://static.oschina.net/uploads/img/201509/10134039_8jTR.png" width="703" height="86" /></a></p>  <p>系统只能安装32位的</p>  <p><a href="http://static.oschina.net/uploads/img/201509/10134039_4jCL.png"><img title="Unnamed QQ Screenshot20150910132041" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150910132041" src="http://static.oschina.net/uploads/img/201509/10134040_aB7M.png" width="532" height="156" /></a></p>  <p>解决方案</p>  <p>第一步先点开任务管理器-性能-cpu</p>  <p>&#160;</p>  <p><a href="http://static.oschina.net/uploads/img/201509/10134040_r974.png"><img title="Unnamed QQ Screenshot20150910132133" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150910132133" src="http://static.oschina.net/uploads/img/201509/10134040_gyst.png" width="390" height="186" /></a></p>  <p>显示cpu虚拟化已启动就是正常的，未启动则进入bios里打开vt虚拟化</p>  <p>看到已经启动还是无法解决，则看本机有没有安装其他的虚拟机产生不兼容</p>  <p>最可能的是自带的hyper-x</p>  <p>打开控制面板-程序-程序和功能-启动或关闭windows功能</p>  <p><a href="http://static.oschina.net/uploads/img/201509/10134040_SWDP.png"><img title="Unnamed QQ Screenshot20150910132438" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150910132438" src="http://static.oschina.net/uploads/img/201509/10134040_bGvc.png" width="429" height="425" /></a></p>      <p>hyper-v已经启动，这里要是自己不用可以关闭这个功能，把勾去掉就行，如果需要用到vs的安卓和wp虚拟机的话还是保留的好</p>  <p>如果关了vbox就能正常用了，如果不得已不能关，可以考虑vbox到hyper的虚拟机转移</p>  <p>下面是转移步骤</p>  <p>打开vbox管理器-管理-虚拟介质管理器-虚拟硬盘</p>  <p><a href="http://static.oschina.net/uploads/img/201509/10134041_Z6lj.png"><img title="Unnamed QQ Screenshot20150910132740" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150910132740" src="http://static.oschina.net/uploads/img/201509/10134041_SgbX.png" width="636" height="499" /></a></p>  <p>在虚拟硬盘点击右键，复制，下一步</p>  <p><a href="http://static.oschina.net/uploads/img/201509/10134204_3Rjn.png"><img title="Unnamed QQ Screenshot20150910132824" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150910132824" src="http://static.oschina.net/uploads/img/201509/10134205_oe3C.png" width="401" height="442" /></a></p>    <p>这里选到vhd(虚拟硬盘)，最后选个位置保存成vhd格式额度虚拟硬盘</p>  <p>然后在hyper-v管理器中新建虚拟机，在设置连接虚拟硬盘时使用现有的虚拟硬盘</p>  <p><a href="http://static.oschina.net/uploads/img/201509/10134205_kEi7.png"><img title="Unnamed QQ Screenshot20150910133119" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150910133119" src="http://static.oschina.net/uploads/img/201509/10134205_XMRq.png" width="718" height="540" /></a></p>  <p>配置好启动</p>  <p><a href="http://static.oschina.net/uploads/img/201509/10134205_yi8K.png"><img title="Unnamed QQ Screenshot20150910134005" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150910134005" src="http://static.oschina.net/uploads/img/201509/10134206_SO7v.png" width="637" height="294" /></a></p>    <p>完全ok</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_500951" href="http://my.oschina.net/tmj1993/blog/500951">C-BlogServer博客-数据库以及验证码的解决</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-09-03 19:04:56</div>
	  <div class='catalog'>分类：BlogServer博客服务器</div>
	  	  	  	  	  </div>
      <div class='content'><p>在第三章合并c并发的server服务器以及调用django的wsgi接口两部分内容后，只需要做django内部的编写就可以写出网站</p>  <p>这里mark一下使用pil的方法</p>  <p>apt-get install libjpeg8 libjpeg62-dev libfreetype6 libfreetype6-dev   <br />ln -s /usr/lib/x86_64-linux-gnu/libjpeg.so /usr/lib    <br />ln -s /usr/lib/x86_64-linux-gnu/libfreetype.so /usr/lib    <br />ln -s /usr/lib/x86_64-linux-gnu/libz.so /usr/lib    <br />ln -s /usr/include/freetype2 /usr/include/freetype    <br />pip install PIL --allow-external PIL --allow-unverified PIL</p>  <p>可是事实上第三章只测试了静态html网页的可用性</p>  <p>在实际的blog网站中，遇到了一些问题</p>  <p>问题以及解决方案</p>  <p>1，数据库读写问题</p>  <p>使用我写的server服务器，第一个问题就出现在这，只要涉及到数据库的读写都会出现这个问题，根据提示我们不难发现是线程的问题，搜索一下没有什么合理的解决方案，尝试根据错误提示来查找问题的所在</p>  <p>DatabaseWrapper objects created in a thread can only be used in that same thread.</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190449_4rqh.png"><img title="Unnamed QQ Screenshot20150903152043" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903152043" src="http://static.oschina.net/uploads/img/201509/03190450_TdHb.png" width="898" height="97" /></a></p>  <p>既然写着thread id，我们尝试在源程序中将所有创建的线程都printf出他的pid</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190450_3KB7.png"><img title="Unnamed QQ Screenshot20150903152349" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903152349" src="http://static.oschina.net/uploads/img/201509/03190450_wvxo.png" width="301" height="147" /></a></p>  <p>不难发现，主线程和响应线程导致这个问题，怎么办呢，肯定将主线程中一些涉及到python数据库的代码转移到响应线程中</p>  <p>回到main函数，我们调用了两个python相关的函数，都是自己定义的方法，包括djangoinit和djangodestory（排除）</p>  <p>其中init方法里头</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190451_QSjN.png"><img title="Unnamed QQ Screenshot20150903152636" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903152636" src="http://static.oschina.net/uploads/img/201509/03190451_zQZc.png" width="590" height="365" /></a></p>  <p>里面只有少数的方法，包括py环境初始化，设置工作目录，导入wsgi，再获取application方法</p>  <p>其实只有包导入和获取部分放到响应线程中完成即可</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190452_XAlO.png"><img title="Unnamed QQ Screenshot20150903152904" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903152904" src="http://static.oschina.net/uploads/img/201509/03190453_FPdG.png" width="702" height="460" /></a></p>  <p>编译测试一下</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190453_0yjg.png"><img title="Unnamed QQ Screenshot20150903153003" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903153003" src="http://static.oschina.net/uploads/img/201509/03190453_nRbO.png" width="335" height="203" /></a></p>  <p>可以正常打开网站了</p>        <p>这里头我们立马发现第二个问题</p>  <p>2，验证码无法显示</p>  <p>无法显示原因是什么的，单从浏览器很难看出来</p>  <p>利用chrome我们打开验证码图片链接</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190453_heRu.png"><img title="Unnamed QQ Screenshot20150903153236" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903153236" src="http://static.oschina.net/uploads/img/201509/03190454_c8Yz.png" width="488" height="294" /></a></p>  <p>发现了错误原因</p>  <p>使用了重复的标头，这个怎么解决呢？</p>  <p>我们用fiddler来看传输的文本内容</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190454_DIos.png"><img title="Unnamed QQ Screenshot20150903153342" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903153342" src="http://static.oschina.net/uploads/img/201509/03190455_on8E.png" width="628" height="121" /></a></p>    <p>不难发现在响应头部分</p>  <p>Content-length有两个，也就是说静态文件在django上会添加上响应头</p>  <p>然后实际上就算去掉重复的头，c根据wsgi接口得到的数据也只有9byte</p>  <p>用回python对接口调用</p>  <p>from mysite import wsgi</p>  <p>class HttpHandler:   <br />&#160;&#160;&#160; status = None    <br />&#160;&#160;&#160; body = None    <br />&#160;&#160;&#160; def start_response(self,status, response_headers, exc_info=None):    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.status = str(status)    <br />&#160;&#160;&#160; def HttpServer(self,method,path,req):    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; environ = {'REQUEST_METHOD':method,'SERVER_NAME':'BlogServer','QUERY_STRING':req,'SERVER_PORT':'80','PATH_INFO':path,'wsgi.input':''}    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.body = str(wsgi.application(environ,self.start_response))    <br />&#160;&#160;&#160; def Run(self):    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.HttpServer('GET','/captcha/image/fa75e9edf75866e81e0146855d17345c92bcfe22/','')    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; return self.status+'\r\n'+self.body    <br />print HttpHandler().Run()</p>  <p>显示的是完整图片的byte</p>  <p>问题在于c调用python时返回值，为什么是9byte</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190455_RfOy.png"><img title="Unnamed QQ Screenshot20150903153342" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903153342" src="http://static.oschina.net/uploads/img/201509/03190455_JWrW.png" width="628" height="121" /></a></p>  <p>最后一位刚好是00，难道在c中把这一位当成\0终结？</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190456_QWc5.png"><img title="Unnamed QQ Screenshot20150903184159" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903184159" src="http://static.oschina.net/uploads/img/201509/03190456_221P.png" width="959" height="290" /></a></p>    <p>强行复制内存，无效</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03190457_dODh.png"><img title="Unnamed QQ Screenshot20150903184315" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903184315" src="http://static.oschina.net/uploads/img/201509/03190457_yjXZ.png" width="80" height="52" /></a></p>  <p>依然打不开图片</p>  <p>虽然打不开图片，但修改一下排除掉重复标头可以正常访问一下</p>  <p>3，POST的header以及cookie等请求头并没有作为参数传参</p>  <p>这些问题在后续博客中继续研究</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_500909" href="http://my.oschina.net/tmj1993/blog/500909">Python-BlogServer博客-Django博客效果</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-09-03 15:13:58</div>
	  <div class='catalog'>分类：BlogServer博客服务器</div>
	  	  	  	  	  </div>
      <div class='content'><p>上期出现的一个问题就是静态文件无法显示，解决方案会在下篇解决，这篇主要讲django博客的建立</p>  <p>先是博客，由于本人对css这些只能稍微写写，而且很麻烦，就更别说什么好的效果了，所以只做出html博客</p>  <p>前端是不会怎么写了，只写了后端</p>  <p>重要目录结构：</p>  <p>-blog（读写博客）</p>  <p>urlpatterns = patterns('',   <br />&#160;&#160;&#160; url(r'^w_blog/$', w_blog),    <br />&#160;&#160;&#160; url(r'^w_blog_up/$', w_blog_up),    <br />&#160;&#160;&#160; url(r'^myblog/(?P&lt;id&gt;\d+)/$', all_blog),    <br />)</p>  <p>-captcha（第三方包，验证码）</p>  <p>-login（登录注销注册）</p>  <p>urlpatterns = patterns('',   <br />&#160;&#160;&#160; url(r'^signup/', signup),    <br />&#160;&#160;&#160; url(r'^login/', login),    <br />&#160;&#160;&#160; url(r'^logout/', logout),    <br />)</p>  <p>-search（搜索分词）</p>  <p>urlpatterns = patterns('',   <br />&#160;&#160;&#160; url(r'^$',search),    <br />&#160;&#160;&#160; url(r'^create_index/$',create_index),    <br />&#160;&#160;&#160; url(r'^deep/$',search_deep),    <br />)    <br />-static（静态文件）</p>  <p>-db（sqlite数据库）</p>  <p>-mysite（配置）</p>  <p>先通过自带的manage管理来运行服务器</p>  <p>python manage.py migrate</p>  <p>python managr.py runserver 0.0.0.0:80</p>  <p>运行</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03151355_ASZR.png"><img title="Unnamed QQ Screenshot20150903150316" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903150316" src="http://static.oschina.net/uploads/img/201509/03151355_NYrl.png" width="517" height="143" /></a></p>  <p>打开主页</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03151355_0EfS.png"><img title="Unnamed QQ Screenshot20150903145911" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903145911" src="http://static.oschina.net/uploads/img/201509/03151355_SlKl.png" width="255" height="258" /></a></p>  <p>没有css真的很简陋</p>  <p>功能也是不多的</p>      <p>注册</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03151356_sVoo.png"><img title="Unnamed QQ Screenshot20150903150335" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903150335" src="http://static.oschina.net/uploads/img/201509/03151356_1Vu1.png" width="311" height="210" /></a></p>  <p>随便注册一下</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03151356_7ozB.png"><img title="Unnamed QQ Screenshot20150903150419" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903150419" src="http://static.oschina.net/uploads/img/201509/03151356_8ECx.png" width="334" height="205" /></a></p>  <p>注册成功后</p>      <p><a href="http://static.oschina.net/uploads/img/201509/03151356_1s2P.png"><img title="Unnamed QQ Screenshot20150903150505" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903150505" src="http://static.oschina.net/uploads/img/201509/03151356_pVP8.png" width="255" height="245" /></a></p>  <p>点击logout退出</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03151357_jPNu.png"><img title="Unnamed QQ Screenshot20150903150526" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903150526" src="http://static.oschina.net/uploads/img/201509/03151357_jtTF.png" width="823" height="77" /></a></p>  <p>也可以登录</p>  <p>写博客</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03151357_ufiN.png"><img title="Unnamed QQ Screenshot20150903150622" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903150622" src="http://static.oschina.net/uploads/img/201509/03151357_z3I5.png" width="250" height="114" /></a></p>  <p>读博客</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03151358_y6jX.png"><img title="Unnamed QQ Screenshot20150903150704" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903150704" src="http://static.oschina.net/uploads/img/201509/03151358_4JuF.png" width="388" height="644" /></a></p>  <p>点开一条</p>  <p><a href="http://static.oschina.net/uploads/img/201509/03151358_bRD0.png"><img title="Unnamed QQ Screenshot20150903150727" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903150727" src="http://static.oschina.net/uploads/img/201509/03151358_sxoq.png" width="546" height="110" /></a></p>  <p>搜索</p>          <p><a href="http://static.oschina.net/uploads/img/201509/03151359_ES9Z.png"><img title="Unnamed QQ Screenshot20150903150925" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150903150925" src="http://static.oschina.net/uploads/img/201509/03151359_lbjT.png" width="557" height="269" /></a></p>  <p>效果演示就到此结束了下一章就要合并前面部分的内容以及把一些bug解决掉实现可用的效果，以后的章节也许会更深入讲解一下这个博客的代码</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_500342" href="http://my.oschina.net/tmj1993/blog/500342">C-BlogServer博客-基于Django的wsgi接口多线程C服务器</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-09-01 21:09:36</div>
	  <div class='catalog'>分类：BlogServer博客服务器</div>
	  	  	  	  	  </div>
      <div class='content'><p>基于第一第二篇博客的内容来综合写的这篇博客</p>  <p>第二篇中的python调用将加入到第一篇的多线程c服务器中</p>  <p>将第二篇中的main函数分割</p>  <p>PyObject *pModule;   <br />PyObject *pFunc;    <br />PyObject *module;    <br />PyObject *response;</p>  <p>int DjangoInit()//c调用python的django，初始化   <br />{    <br />&#160;&#160;&#160; Py_Initialize();    <br />&#160;&#160;&#160; if (!Py_IsInitialized()) return -1;    <br />&#160;&#160;&#160; PyRun_SimpleString(&quot;import sys&quot;);    <br />&#160;&#160;&#160; PyRun_SimpleString(&quot;sys.path.append('./')&quot;);    <br />&#160;&#160;&#160; pModule = PyImport_ImportModule(&quot;mysite.wsgi&quot;);    <br />&#160;&#160;&#160; if(!pModule){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&quot;import failed!\n&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return 1;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; pFunc = PyObject_GetAttrString(pModule, &quot;application&quot;);    <br />&#160;&#160;&#160; if(!pFunc){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&quot;get function failed!\n&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return 1;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160; module = Py_InitModule(&quot;start_response&quot;, start_response_methods);    <br />&#160;&#160;&#160; response = PyObject_GetAttrString(module, &quot;start_response&quot;);    <br />&#160;&#160;&#160; return 0;    <br />}</p>  <p>char* DjangoResponse(char* method,char* url,char* query)//初始化后可以返回提交网页请求   <br />{    <br />&#160;&#160;&#160; PyObject *environ = PyDict_New();    <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;REQUEST_METHOD&quot;, PyString_FromString(method));    <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;SERVER_NAME&quot;, PyString_FromString(&quot;BlogServer&quot;));    <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;SERVER_PORT&quot;, PyString_FromString(&quot;80&quot;));    <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;QUERY_STRING&quot;, PyString_FromString(query));    <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;PATH_INFO&quot;, PyString_FromString(url));    <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;wsgi.input&quot;, PyString_FromString(&quot;&quot;));    <br />&#160;&#160;&#160; PyObject *pArgs = PyTuple_New(2);    <br />&#160;&#160;&#160; PyTuple_SetItem(pArgs, 0, environ);    <br />&#160;&#160;&#160; PyTuple_SetItem(pArgs, 1, response);    <br />&#160;&#160;&#160; char *http=PyString_AsString(PyObject_Str(PyObject_CallObject(pFunc, pArgs)));    <br />&#160;&#160;&#160; return http;    <br />}</p>  <p>   <br />void DjangoDestory()//最后销毁    <br />{    <br />&#160;&#160;&#160; Py_DECREF(response);    <br />&#160;&#160;&#160; Py_DECREF(pModule);    <br />&#160;&#160;&#160; Py_DECREF(pFunc);    <br />&#160;&#160;&#160; Py_Finalize();    <br />&#160;&#160;&#160; Py_DECREF(module);    <br />}</p>  <p>其中还有一个很重要的回调函数，里面会设置http相应状态码，这个由于是多线程的不能使用静态全局变量，即便是加锁互斥也会对效率造成影响，实际上这个变量完全没有必要在线程间共享，这时候我们要用到线程私有变量，共享变量名</p>  <p>pthread_key_t key;//共享变量名</p>  <p>void dest(void *buf)&#160;&#160; <br />{&#160;&#160; <br />&#160;&#160;&#160; //printf(&quot;destructor excuted in thread %d,param=%s\n&quot;,(int)pthread_self(),(char*)buf);&#160;&#160; <br />}</p>  <p>static PyObject *start_response(PyObject *self, PyObject *args)   <br />{    <br />&#160;&#160;&#160; pthread_setspecific(key,(void *)PyString_AsString(PyObject_Str(PyTuple_GetItem(args, 0))));//写入线程私有key变量    <br />&#160;&#160;&#160; //printf(&quot;%s\n&quot;,PyString_AsString(PyObject_Str(PyTuple_GetItem(args, 0))));    <br />&#160;&#160;&#160; //printf(&quot;%s\n&quot;,PyString_AsString(PyObject_Str(PyTuple_GetItem(args, 1))));    <br />&#160;&#160;&#160; //printf(&quot;%s\n&quot;,PyString_AsString(PyObject_Str(PyTuple_GetItem(args, 2))));    <br />&#160;&#160;&#160; return Py_None;    <br />}</p>  <p>   <br />static struct PyMethodDef start_response_methods[] = {    <br />&#160;&#160;&#160; {&quot;start_response&quot;, start_response, METH_VARARGS},    <br />&#160;&#160;&#160; {NULL, NULL}};</p>  <p>主函数部分增加django框架初始化以及销毁操作，同时增加创建key操作</p>  <p>int main(int argc,char* argv[])   <br />{    <br />&#160;&#160;&#160; if(argc != 2) return 1;    <br />&#160;&#160;&#160; int server_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);    <br />&#160;&#160;&#160; printf(&quot;socket_fd:%d\n&quot;, server_fd);    <br />&#160;&#160;&#160; struct sockaddr_in server_addr;    <br />&#160;&#160;&#160; server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    <br />&#160;&#160;&#160; server_addr.sin_family = AF_INET;    <br />&#160;&#160;&#160; server_addr.sin_port = htons(atoi(argv[1]));    <br />&#160;&#160;&#160; int val = 1;    <br />&#160;&#160;&#160; setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &amp;val, sizeof(int));    <br />&#160;&#160;&#160; setsockopt(server_fd, SOL_SOCKET, SO_REUSEPORT, &amp;val, sizeof(int));    <br />&#160;&#160;&#160; if(!bind(server_fd, (struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr))) {char buf[30];printf(&quot;bind:%s:%d\n&quot;,inet_ntop(AF_INET, &amp;server_addr.sin_addr, buf, sizeof(buf)),(unsigned int)ntohs(server_addr.sin_port));}    <br />&#160;&#160;&#160; else return 1;    <br />&#160;&#160;&#160; if(!listen(server_fd, 100)) {char buf[30];printf(&quot;listen:%s:%d\n&quot;,inet_ntop(AF_INET, &amp;server_addr.sin_addr, buf, sizeof(buf)),(unsigned int)ntohs(server_addr.sin_port));}    <br />&#160;&#160;&#160; else return 1;    <br />&#160;&#160;&#160; <br />&#160;&#160;&#160; if(DjangoInit()) return 1;//python初始化    <br />&#160;&#160;&#160; pthread_key_create(&amp;key,dest);//key创建    <br />&#160;&#160;&#160; pthread_t ntid;    <br />&#160;&#160;&#160; pthread_create(&amp;ntid, NULL, ListenClient, &amp;server_fd);    <br />&#160;&#160;&#160; <br />&#160;&#160;&#160; int loop;    <br />&#160;&#160;&#160; scanf(&quot;%d&quot;,&amp;loop);</p>  <p>&#160;&#160;&#160; close(server_fd);   <br />&#160;&#160;&#160; pthread_key_delete(key);//销毁key    <br />&#160;&#160;&#160; DjangoDestory();//python环境回收    <br />&#160;&#160;&#160; return 0;    <br />}</p>  <p>最后就是socket读写交互与django的相应拼接了</p>  <p>void *HttpResponse(void *client)   <br />{    <br />&#160;&#160;&#160; int client_fd = *(int*)client;    <br />&#160;&#160;&#160; char recvBuf[1024];    <br />&#160;&#160;&#160; recv(client_fd, recvBuf, sizeof(recvBuf), 0);    <br />&#160;&#160;&#160; char *p = strtok(recvBuf, &quot;\r\n&quot;);    <br />&#160;&#160;&#160; int err = 1;    <br />&#160;&#160;&#160; if(p != NULL){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; char *method = strtok(p, &quot; &quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(method != NULL){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; p = strtok(NULL,&quot; &quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; char *url = strtok(p,&quot;?&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(url != NULL){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; char *query = strtok(NULL,&quot; &quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(query == NULL) query = &quot;&quot;;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; char s1[100];    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; char *s2 = DjangoResponse(method, url, query);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(s2 != NULL){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; char *s = strstr(s2,&quot;\r\n\r\n&quot;);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(s != NULL){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sprintf(s1, &quot;HTTP/1.1 %s\r\nServer:BlogServer\r\nContent-Length:%d\r\n&quot;, (char*)pthread_getspecific(key), (int)strlen(s) - 3);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //printf(&quot;%s\n%s\n%s\n%s\n&quot;,method, url, query, s2);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int size = strlen(s1)+strlen(s2)+1;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; char *sendBuf = malloc(size);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; strcpy(sendBuf, s1);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; strcat(sendBuf, s2);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sendBuf[size-1] = '\0';    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; send(client_fd, sendBuf, size, 0);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; free(sendBuf);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; else err = 0;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; else err = 0;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; else err = 0;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; else err = 0;    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; else err = 0;    <br />&#160;&#160;&#160; if(!err){    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; char sendBuf[] = &quot;HTTP/1.1 404 NOT FOUND\r\nServer:BlogServer\r\nContent-Length:0\r\n\r\n&quot;;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; send(client_fd, sendBuf, sizeof(sendBuf), 0);    <br />&#160;&#160;&#160; }    <br />&#160;&#160;&#160; shutdown(client_fd, SHUT_RDWR);    <br />&#160;&#160;&#160; close(client_fd);    <br />&#160;&#160;&#160; pthread_exit((void *)0);    <br />}</p>  <p>对从客户端读取到的第一条重要的信息进行分割</p>  <p>GET /a?b HTTP1.1</p>  <p>得到</p>  <p>method为GET</p>  <p>path为/a</p>  <p>query为b</p>  <p>这样分割得到的消息传到DjangoResponse即可得到正文</p>  <p>正文去掉头再strlen()获得长度作为Content-Length</p>  <p>由于中间涉及太多指针操作，都要判断是否为空避免异常，c也没有很好的异常机制只能手动来处理一下</p>  <p>最后就上个图吧</p>  <p><a href="http://static.oschina.net/uploads/img/201509/01210937_Dar1.png"><img title="Unnamed QQ Screenshot20150901210708" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150901210708" src="http://static.oschina.net/uploads/img/201509/01210937_DnOR.png" width="706" height="404" /></a></p>  <p>其实还是有一些问题没有解决，最主要的是静态文件没法返回，实际上直接用原来的wsgi接口来进行静态文件请求也是失败的，可能wsgi接口处理上仍然不够完善，以及post方法并没有进行测试，这也许要留到下一章进行更深度的分析了</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_500171" href="http://my.oschina.net/tmj1993/blog/500171">Python-BlogServer博客-C调用Python的wsgi接口</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-09-01 15:12:28</div>
	  <div class='catalog'>分类：BlogServer博客服务器</div>
	  	  	  	  	  </div>
      <div class='content'><h3><font style="font-weight: normal">Python Web Server Gateway Interface</font></h3>  <p>python的wsgi接口，调用这个接口的主要原因在于要使用python作为动态网站的后端语言(c语言作为后端编写起来还是很慢的，除非是静态网站，静态网站纯c服务器也许会在后面继续研究)，socket连接采用前一章写的c程序</p>  <p>python的wsgi接口参考：<a title="https://www.python.org/dev/peps/pep-3333/" href="https://www.python.org/dev/peps/pep-3333/">https://www.python.org/dev/peps/pep-3333/</a></p>  <p>python的c api接口参考：<a title="https://docs.python.org/2.7/c-api/" href="https://docs.python.org/2.7/c-api/">https://docs.python.org/2.7/c-api/</a></p>  <p>有了上面资料就开始这一章的编程了</p>  <p>首先后端采用python的django框架</p>  <p>django官网：<a title="https://www.djangoproject.com/" href="https://www.djangoproject.com/">https://www.djangoproject.com/</a></p>  <p>对于python使用pip安装即可，这里使用的是最新的1.8.4</p>  <pre><code><font size="4" face="微软雅黑">pip install Django==1.8.4</font></code></pre>

<pre><font face="微软雅黑">安装完成后</font></pre>

<pre><font face="微软雅黑">django-admin startproject mysite</font></pre>

<pre><font face="微软雅黑">即可安装配置好项目</font></pre>

<pre><font size="4" face="微软雅黑">然后我们可以看到mysite目录下结构</font></pre>

<pre><font size="4" face="微软雅黑">-mysite</font></pre>

<pre><font size="4" face="微软雅黑">--_init_.py</font></pre>

<pre><font size="4" face="微软雅黑">--setting.py</font></pre>

<pre><font size="4" face="微软雅黑">--urls.py</font></pre>

<pre><font size="4" face="微软雅黑">--wsgi.py</font></pre>

<pre><font size="4" face="微软雅黑">-manage.py</font></pre>

<pre><font size="4" face="微软雅黑">其中wsgi是就是重要的接口文件</font></pre>

<pre><font size="4" face="微软雅黑">首先我们可以直接用python对接口进行测试</font></pre>

<p>from mysite import wsgi</p>

<p>def start_response(status, response_headers, exc_info=None):
  <br />&#160;&#160;&#160; print status</p>

<p>def HttpServer(method,path,req):
  <br />&#160;&#160;&#160; environ = {'REQUEST_METHOD':method,'SERVER_NAME':'BlogServer','QUERY_STRING':req,'SERVER_PORT':'80','PATH_INFO':path,'wsgi.input':''}

  <br />&#160;&#160;&#160; return wsgi.application(environ,start_response)</p>

<p>print HttpServer('GET','/admin/1/2','')#为了方便我们仅仅提取出三个接口，对于get方法，只有与请求链接与查询字符串两部分</p>

<p>这个文件保存在顶层mysite目录下，而不是mysite/mysite/目录下</p>

<p>由于我们请求一个不存在的链接所以会返回404状态码以及响应头和html正文</p>

<p><a href="http://static.oschina.net/uploads/img/201509/01151227_CQGA.png"><img title="Unnamed QQ Screenshot20150901145013" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150901145013" src="http://static.oschina.net/uploads/img/201509/01151228_C9iT.png" width="574" height="208" /></a></p>

<p>&#160;</p>

<p>修改请求/admin/</p>

<p><a href="http://static.oschina.net/uploads/img/201509/01151228_L7pt.png"><img title="Unnamed QQ Screenshot20150901145159" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150901145159" src="http://static.oschina.net/uploads/img/201509/01151228_WBLC.png" width="437" height="160" /></a></p>

<p>302重定向</p>

<p>再修改成HttpServer('GET','/admin/login/','next=/admin/')</p>

<p><a href="http://static.oschina.net/uploads/img/201509/01151228_R3kH.png"><img title="Unnamed QQ Screenshot20150901145342" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150901145342" src="http://static.oschina.net/uploads/img/201509/01151228_gw8B.png" width="422" height="197" /></a></p>

<p>这次就是200正常响应了</p>

<p>根据上面python的wsgi接口的调用我们也知道该如果使用该接口，接下来就是用c语言来调用这个接口了</p>

<p>对于c调用python这部分内容在国内的网站极少描述，啃了好久官方的英文文档</p>

<p>#include &lt;python2.7/Python.h&gt;
  <br />#include &lt;stdio.h&gt;</p>

<p>static PyObject *start_response(PyObject *self, PyObject *args)//相当于上面python里面的start_response
  <br />{

  <br />&#160;&#160;&#160; printf(&quot;%s\n&quot;,PyString_AsString(PyObject_Str(PyTuple_GetItem(args, 0))));

  <br />&#160;&#160;&#160; printf(&quot;%s\n&quot;,PyString_AsString(PyObject_Str(PyTuple_GetItem(args, 1))));

  <br />&#160;&#160;&#160; return Py_None;

  <br />}</p>

<p>static struct PyMethodDef start_response_methods[] = {</p>

<p>//构建module使用，可能我还能吭透官方文档，所不能有直接回调的PyObject *构建方法
  <br />&#160;&#160;&#160; {&quot;start_response&quot;, start_response, METH_VARARGS},

  <br />&#160;&#160;&#160; {NULL, NULL}};</p>

<p>int main()
  <br />{

  <br />&#160;&#160;&#160; Py_Initialize();//初始化

  <br />&#160;&#160;&#160; if (!Py_IsInitialized()) return -1;//是否正确初始化

  <br />&#160;&#160;&#160; PyRun_SimpleString(&quot;import sys&quot;);//导入sys

  <br />&#160;&#160;&#160; PyRun_SimpleString(&quot;sys.path.append('./')&quot;);//设置当前目录为工作目录

  <br />&#160;&#160;&#160; PyObject *pModule = PyImport_ImportModule(&quot;mysite.wsgi&quot;);//导入wsgi接口

  <br />&#160;&#160;&#160; if(!pModule){

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&quot;import failed!\n&quot;);//导入失败提示

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return -1;

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }

  <br />&#160;&#160;&#160; PyObject *pFunc = PyObject_GetAttrString(pModule, &quot;application&quot;);//导入wsgi的调用

  <br />&#160;&#160;&#160; if(!pFunc){

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&quot;get function failed!\n&quot;);//失败提示

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return -1;

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }

  <br />&#160;&#160;&#160; PyObject *environ = PyDict_New();//构建python的字典类型

  <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;REQUEST_METHOD&quot;, PyString_FromString(&quot;GET&quot;));

  <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;SERVER_NAME&quot;, PyString_FromString(&quot;BlogServer&quot;));

  <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;SERVER_PORT&quot;, PyString_FromString(&quot;80&quot;));

  <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;QUERY_STRING&quot;, PyString_FromString(&quot;&quot;));

  <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;PATH_INFO&quot;, PyString_FromString(&quot;/&quot;));

  <br />&#160;&#160;&#160; PyDict_SetItemString(environ, &quot;wsgi.input&quot;, PyString_FromString(&quot;&quot;));</p>

<p>&#160;&#160;&#160; PyObject *module = Py_InitModule(&quot;start_response&quot;, start_response_methods);
  <br />&#160;&#160;&#160; PyObject *response = PyObject_GetAttrString(module, &quot;start_response&quot;);//还要从module里获取回需要的回调方法(也许有更好的办法)</p>

<p>&#160;&#160;&#160; PyObject *pArgs = PyTuple_New(2);//构建元组类型，传参使用</p>

<p>&#160;&#160;&#160; PyTuple_SetItem(pArgs, 0, environ);
  <br />&#160;&#160;&#160; PyTuple_SetItem(pArgs, 1, response);

  <br />&#160;&#160;&#160; PyObject *res = PyObject_CallObject(pFunc, pArgs);

  <br />&#160;&#160;&#160; printf(&quot;%s&quot;,PyString_AsString(PyObject_Str(res)));//打印结果</p>

<p>&#160;&#160;&#160; //把指针都回收销毁掉</p>

<p>&#160;&#160;&#160; Py_DECREF(res);
  <br />&#160;&#160;&#160; Py_DECREF(pArgs);

  <br />&#160;&#160;&#160; Py_DECREF(response);

  <br />&#160;&#160;&#160; Py_DECREF(environ);

  <br />&#160;&#160;&#160; Py_DECREF(pModule);

  <br />&#160;&#160;&#160; Py_DECREF(pFunc);

  <br />&#160;&#160;&#160; Py_Finalize();

  <br />&#160;&#160;&#160; Py_DECREF(module);</p>

<p>
  <br />&#160;&#160;&#160; return 0;

  <br />}</p>

<p>python2.7编译一下</p>

<p>gcc cpy.c&#160; -o cpy -lpython2.7
  <br /><a href="http://static.oschina.net/uploads/img/201509/01151228_2CnZ.png"><img title="Unnamed QQ Screenshot20150901150809" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150901150809" src="http://static.oschina.net/uploads/img/201509/01151229_nNhj.png" width="572" height="261" /></a></p>

<p>编译运行一下</p>

<p>PyObject其实就是python中的变量名，却没有固定的一个数据类型，在c语言中也是这么体现的，感觉有点特别，等下一部分将会合并前面多线程socket编程，构成一个正常的服务器</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_495645" href="http://my.oschina.net/tmj1993/blog/495645">C-BlogServer博客-可并发的http服务器</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-08-21 22:02:46</div>
	  <div class='catalog'>分类：BlogServer博客服务器</div>
	  	  	  	  	  </div>
      <div class='content'><p>这一部分主要是先把现有代码讲述一下方便后面的博客描写</p>  <p>ps:我也是初学者，不保证代码的可靠性，只是能用，现有代码的问题也许会在后面修正，这取决于个人的学习深度，由于是学习向的，不采用任何的第三方库</p>  <p>运行在Linux环境下</p>  <p>首先来个单线程的</p>  <p>#include &lt;sys/socket.h&gt;    <br />#include &lt;arpa/inet.h&gt;    <br />#include &lt;netinet/in.h&gt;    <br />#include &lt;stdio.h&gt;</p>  <p>int main()   <br />{    <br />&#160;&#160;&#160; int server_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);//IPV4+TCP    <br />&#160;&#160;&#160; struct sockaddr_in server_addr;    <br />&#160;&#160;&#160; server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    <br />&#160;&#160;&#160; server_addr.sin_family = AF_INET;    <br />&#160;&#160;&#160; server_addr.sin_port = htons(8080);//监听端口    <br />&#160;&#160;&#160; bind(server_fd, (struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr));    <br />&#160;&#160;&#160; listen(server_fd, 1);    <br />&#160;&#160;&#160; int len = sizeof(struct sockaddr);    <br />&#160;&#160;&#160; struct sockaddr_in client_addr;    <br />&#160;&#160;&#160; int client_fd = accept(server_fd, (struct sockaddr*)&amp;client_addr, &amp;len);    <br />&#160;&#160;&#160; char recvBuf[1024];    <br />&#160;&#160;&#160; recv(client_fd, recvBuf, sizeof(recvBuf), 0);//接收浏览器发过来的请求    <br />&#160;&#160;&#160; char sendBuf[]=&quot;HTTP/1.1 200 OK\r\nServer:BlogServer\r\nContent-Length:18\r\n\r\n&lt;p&gt;hello world&lt;/p&gt;&quot;;//包括http响应头和正文&lt;p&gt;hello world&lt;/p&gt;    <br />&#160;&#160;&#160; send(client_fd, sendBuf, sizeof(sendBuf), 0);//不对请求分析统一返回上面的字符串    <br />&#160;&#160;&#160; shutdown(client_fd, SHUT_RDWR);//关闭    <br />&#160;&#160;&#160; close(client_fd);    <br />&#160;&#160;&#160; close(server_fd);    <br />&#160;&#160;&#160; return 0;    <br />}</p>  <p><a href="http://static.oschina.net/uploads/img/201508/21220236_9rsv.png"><img title="Unnamed QQ Screenshot20150821174715" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821174715" src="http://static.oschina.net/uploads/img/201508/21220237_tDMM.png" width="646" height="477" /></a></p>  <p>然后通过gcc编译一下</p>  <p><a href="http://static.oschina.net/uploads/img/201508/21220237_5Hzz.png"><img title="Unnamed QQ Screenshot20150821174908" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821174908" src="http://static.oschina.net/uploads/img/201508/21220237_IoUh.png" width="298" height="50" /></a></p>  <p>运行</p>  <p><a href="http://static.oschina.net/uploads/img/201508/21220237_LqHa.png"><img title="Unnamed QQ Screenshot20150821175155" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821175155" src="http://static.oschina.net/uploads/img/201508/21220238_tF9Y.png" width="279" height="74" /></a></p>  <p>通过chrome打开可以看到hello world</p>  <p>响应信息：</p>  <p><a href="http://static.oschina.net/uploads/img/201508/21220238_XwyP.png"><img title="Unnamed QQ Screenshot20150821175228" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821175228" src="http://static.oschina.net/uploads/img/201508/21220239_3pqQ.png" width="357" height="169" /></a></p>  <p>&#160;</p>      <p>由于这个程序并不是多线程，也没有做循环处理，所以该程序只能运行一次就会退出</p>  <p>然而再次打开的时候却无法继续使用，为什么呢？</p>  <p>首先使用netstat -an看一下端口的占用情况,然而并没有发现8080端口</p>  <p>但是有个看起来比较可疑的http-alt</p> <a href="http://static.oschina.net/uploads/img/201508/21220239_C4PK.png"><img title="Unnamed QQ Screenshot20150821181149" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821181149" src="http://static.oschina.net/uploads/img/201508/21220239_b8z9.png" width="649" height="22" /></a>  <pre><font face="微软雅黑">在查询一下服务发现确实是8080的端口的</font></pre>

<pre><a href="http://static.oschina.net/uploads/img/201508/21220239_70w6.png"><img title="Unnamed QQ Screenshot20150821181759" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821181759" src="http://static.oschina.net/uploads/img/201508/21220239_fBKb.png" width="596" height="51" /></a></pre>

<pre>LISTEN：侦听来自远方的TCP端口的连接请求<br />SYN-SENT：再发送连接请求后等待匹配的连接请求<br />SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认<br />ESTABLISHED：代表一个打开的连接<br />FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认<br />FIN-WAIT-2：从远程TCP等待连接中断请求<br />CLOSE-WAIT：等待从本地用户发来的连接中断请求<br />CLOSING：等待远程TCP对连接中断的确认<br />LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认<br />TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认<br />CLOSED：没有任何连接状态</pre>

<p>查一下资料发现TIME-WAIT是等待远程tcp的确认</p>

<p>经查询发现可以采用端口复用的方式来避免服务器重启等情况</p>

<p>int val = 1;
  <br />setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &amp;val, sizeof(int));

  <br />setsockopt(server_fd, SOL_SOCKET, SO_REUSEPORT, &amp;val, sizeof(int));</p>

<p>在bind()之前加入这两句
  <br /><a href="http://static.oschina.net/uploads/img/201508/21220240_Z2SL.png"><img title="Unnamed QQ Screenshot20150821194340" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821194340" src="http://static.oschina.net/uploads/img/201508/21220241_yE13.png" width="644" height="480" /></a></p>

<p>这时候可以重复地连续地进行启动操作</p>

<p>如果让两个终端同时开启程序，第一个开启的(pid比较小的？)会先执行accept()</p>

<p>然后我们再进行并发的编程</p>

<p>#include &lt;pthread.h&gt;</p>

<p>添加必要的头</p>

<p>int main(int argc,char* argv[])
  <br />{

  <br />&#160;&#160;&#160; if(argc != 2) return 1;

  <br />&#160;&#160;&#160; int server_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);

  <br />&#160;&#160;&#160; printf(&quot;socket_fd:%d\n&quot;, server_fd);

  <br />&#160;&#160;&#160; struct sockaddr_in server_addr;

  <br />&#160;&#160;&#160; server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

  <br />&#160;&#160;&#160; server_addr.sin_family = AF_INET;

  <br />&#160;&#160;&#160; server_addr.sin_port = htons(atoi(argv[1]));

  <br />&#160;&#160;&#160; int val = 1;

  <br />&#160;&#160;&#160; setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &amp;val, sizeof(int));

  <br />&#160;&#160;&#160; setsockopt(server_fd, SOL_SOCKET, SO_REUSEPORT, &amp;val, sizeof(int));

  <br />&#160;&#160;&#160; if(!bind(server_fd, (struct sockaddr*)&amp;server_addr, sizeof(struct sockaddr))) {char buf[30];printf(&quot;bind:%s:%d\n&quot;,inet_ntop(AF_INET, &amp;server_addr.sin_addr, buf, sizeof(buf)),(unsigned int)ntohs(server_addr.sin_port));}

  <br />&#160;&#160;&#160; else return 1;

  <br />&#160;&#160;&#160; if(!listen(server_fd, 1000)) {char buf[30];printf(&quot;listen:%s:%d\n&quot;,inet_ntop(AF_INET, &amp;server_addr.sin_addr, buf, sizeof(buf)),(unsigned int)ntohs(server_addr.sin_port));}

  <br />&#160;&#160;&#160; else return 1;</p>

<p>//accept()将在线程中完成
  <br />&#160;&#160;&#160; pthread_t ntid;

  <br />&#160;&#160;&#160; pthread_create(&amp;ntid, NULL, ListenClient, &amp;server_fd);</p>

<p>//主线程开始等待输入
  <br />&#160;&#160;&#160; int loop;

  <br />&#160;&#160;&#160; scanf(&quot;%d&quot;,&amp;loop);

  <br />&#160;&#160;&#160; close(server_fd);

  <br />&#160;&#160;&#160; return 0;

  <br />}</p>

<p>监听线程</p>

<p>void *ListenClient(void *server)
  <br />{

  <br />&#160;&#160;&#160; int server_fd = *(int*)server;

  <br />&#160;&#160;&#160; int len = sizeof(struct sockaddr);

  <br />&#160;&#160;&#160; struct sockaddr_in client_addr;

  <br />&#160;&#160;&#160; pthread_t ntid;

  <br />&#160;&#160;&#160; while(1)

  <br />&#160;&#160;&#160; {

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; int client_fd = accept(server_fd, (struct sockaddr*)&amp;client_addr, &amp;len);

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //printf(&quot;client_fd:%d\n&quot;, client_fd);

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; char buf[30];

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&quot;connect:%s:%d\n&quot;,inet_ntop(AF_INET, &amp;client_addr.sin_addr, buf, sizeof(buf)),(unsigned int)ntohs(client_addr.sin_port));

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //printf(&quot;%lu:start new response\n&quot;,(unsigned long)pthread_self());

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; //printf(&quot;%d\n&quot;,client_fd);

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; pthread_create(&amp;ntid, NULL, HttpResponse, &amp;client_fd);//每一次响应都创建新的线程来处理

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; pthread_detach(ntid);

  <br />&#160;&#160;&#160; }&#160;&#160;&#160; <br />}</p>

<p>响应线程</p>

<p>void *HttpResponse(void *client)
  <br />{

  <br />&#160;&#160;&#160; int client_fd = *(int*)client;

  <br />&#160;&#160;&#160; char recvBuf[1024];

  <br />&#160;&#160;&#160; //printf(&quot;%lu:start recv\n&quot;,(unsigned long)pthread_self());

  <br />&#160;&#160;&#160; recv(client_fd, recvBuf, sizeof(recvBuf), 0);

  <br />&#160;&#160;&#160; //printf(&quot;%s\n&quot;,recvBuf);

  <br />&#160;&#160;&#160; char sendBuf[]=&quot;HTTP/1.1 200 OK\r\nServer:BlogServer\r\nContent-Length:18\r\n\r\n&lt;p&gt;hello world&lt;/p&gt;&quot;;

  <br />&#160;&#160;&#160; //printf(&quot;%lu:start send\n&quot;,(unsigned long)pthread_self());

  <br />&#160;&#160;&#160; send(client_fd, sendBuf, sizeof(sendBuf), 0);

  <br />&#160;&#160;&#160; shutdown(client_fd, SHUT_RDWR);

  <br />&#160;&#160;&#160; //printf(&quot;%lu:start close\n&quot;,(unsigned long)pthread_self());

  <br />&#160;&#160;&#160; close(client_fd);

  <br />&#160;&#160;&#160; pthread_exit((void *)0);

  <br />}</p>

<p>编译</p>

<p>gcc main.c -o httpserver -lpthread
  <br />这时候可以不停刷新浏览器运行了，还是很不错的</p>

<p><a href="http://static.oschina.net/uploads/img/201508/21220241_FJeu.png"><img title="Unnamed QQ Screenshot20150821202203" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821202203" src="http://static.oschina.net/uploads/img/201508/21220242_TSfa.png" width="312" height="205" /></a></p>

<p>但此时系统还是不完善的，接着看</p>

<p><a href="http://static.oschina.net/uploads/img/201508/21220242_fLFr.png"><img title="Unnamed QQ Screenshot20150821202619" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821202619" src="http://static.oschina.net/uploads/img/201508/21220242_nyeU.png" width="371" height="25" /></a></p>

<p>先用ps a看一下进程pid</p>

<p>再用top命令来观察(top –p 1431)</p>

<p>使用py脚本测试，这个比较简单</p>

<p>#coding=utf-8
  <br />import urllib

  <br />import thread

  <br />import time</p>

<p>i = 0
  <br />while 1:

  <br />&#160;&#160;&#160; try:

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; url = '<a href="http://127.0.0.1:8080'">http://127.0.0.1:8080'</a>

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; res = urllib.urlopen(url)

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; s = res.read()

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; res.close()

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; i = i + 1

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if i % 5 == 0:

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; print str(i)+':'+s

  <br />&#160;&#160;&#160; except Exception as e:

  <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; print str(e)</p>

<p><a href="http://static.oschina.net/uploads/img/201508/21220243_aNPI.png"><img title="Unnamed QQ Screenshot20150821202920" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821202920" src="http://static.oschina.net/uploads/img/201508/21220244_Z3fF.png" width="849" height="372" /></a></p>

<p>在高速地循环运行下，系统依然是很稳健的，毕竟这个简单，但是这是在网络状况极好的状况下，那在网络异常等一下故障情况下，出现超时了是否能处理呢？</p>

<p>import socket
  <br />host='127.0.0.1'

  <br />port=8080

  <br />s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

  <br />s.connect((host,port))

  <br />s.send('hello')

  <br />print s.recv(1024)

  <br />s.close</p>

<p>简单的一次socket连接</p>

<p><a href="http://static.oschina.net/uploads/img/201508/21220244_Cotd.png"><img title="Unnamed QQ Screenshot20150821203719" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Unnamed QQ Screenshot20150821203719" src="http://static.oschina.net/uploads/img/201508/21220244_XO66.png" width="543" height="144" /></a></p>

<p>成功</p>

<p>import socket
  <br />host='127.0.0.1'

  <br />port=8080

  <br />while 1:

  <br />&#160;&#160;&#160; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

  <br />&#160;&#160;&#160; s.connect((host,port))

  <br />&#160;&#160;&#160; s.send('hello')

  <br />&#160;&#160;&#160; s.recv(1024)

  <br />&#160;&#160;&#160; s.close</p>

<p>循环，这时候跟http版本的相似，也是可以正常运行的</p>

<p>这时候要是把recv和close去掉，那么情况就不用乐观了，服务器几乎1秒就挂了</p>

<p>import socket
  <br />import time

  <br />host='127.0.0.1'

  <br />port=8080

  <br />while 1:

  <br />&#160;&#160;&#160; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)

  <br />&#160;&#160;&#160; s.connect((host,port))

  <br />&#160;&#160;&#160; s.send('hello')

  <br />&#160;&#160;&#160; time.sleep(0.01)

  <br />&#160;&#160;&#160; #s.recv(1024)

  <br />&#160;&#160;&#160; #s.close</p>

<p>加上time.sleep(0.001)会缩短崩溃时间，但也不容乐观</p>

<p>问题出在哪里呢？大量的超时连接导致服务器资源过多奔溃吗？加入对客户端超时发生与接收的处理</p>

<p>struct timeval timeout = {5, 0};
  <br />setsockopt(client_fd,SOL_SOCKET,SO_RCVTIMEO,(char*)&amp;timeout,sizeof(struct timeval));

  <br />setsockopt(client_fd,SOL_SOCKET,SO_SNDTIMEO,(char*)&amp;timeout,sizeof(struct timeval));</p>

<p>实际上就算说对超时时间，短时间大量这样的连接还是会奔溃，问题到底出在哪里呢？
  <br />也晚了，等下一篇博客继续研究吧</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_494686" href="http://my.oschina.net/tmj1993/blog/494686">C#-JudgeSystem判题系统-开放实验总结</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-08-19 17:16:51</div>
	  <div class='catalog'>分类：JudgeSystem判题系统</div>
	  	  	  <div class='tags'>标签：C#,Server,编译,多线程,判题系统</div>	  	  	  </div>
      <div class='content'><p><a href="http://static.oschina.net/uploads/img/201508/19171654_wJJw.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150808143824" alt="Unnamed QQ Screenshot20150808143824" src="http://static.oschina.net/uploads/img/201508/19171656_gHgi.png" width="630" height="239"></a></p><p>花了一周的时间去做这个实验中间断断续续完成不同的部分，按照实验过程来一步一步完成感觉实验流程还是相当合理的</p><p>上图就是最后的成品，其中包括</p><p>JudgeCilent客户端</p><p>完成部分:</p><p>1、可以提供五种测试状态的显示，包括网络异常，编译失败，输入错误(超时)，结果错误，接受，五个状态</p><p>2、可以对无输入程序进行测试</p><p>3、可修改ip地址与端口</p><p>可提高部分:</p><p>1、由于该程序只是辅助测试服务器的使用的，所以并没有做一下界面的优化比如线程运行优化来避免等待服务器返回时界面不响应的现象</p><p>JudgeServer服务器</p><p>完成部分:</p><p>1、错误处理，并测试在判题过程的几种意外下能正常运行，以及客户端无连接后会在30秒超时时主动断开连接避免系统空连接过多造成的系统开销</p><p>2、多线程处理，在并发速度为10ms一次连接下，并且带有不同的错误情况下，系统依然能正确运行，高并发下测试判题并没有错误</p><p>可提高部分:</p><p>1、服务器与客户端的交互仍有不完善的地方，一是不方便拓展，一旦服务器修改，客户端必须进行修改，因为数据是按照一定规则分次发送的，而不是结构化一次性发送</p><p>2、暂时没有提供自定义的监听端口与gcc编译程序地址与test编译测试工作目录，这里通过相对地址也就是如图的两个文件夹存放，监听地址固定为8080而没有设置成运行时确定</p><p>CompileTest编译类库</p><p>完成部分:</p><p>1、编译与测试输入输出结果，无输入则通过\r\n来表示</p><p>2、超时机制，可定义超时时间</p><p>3、异常处理，在任何异常下保证系统不会出现不受控制的子进程</p><p>可提高部分:</p><p>1、通过windows api完善编译过程的信息反馈，包括内存，编译运行时长等</p><p>由于c#语言跟系统高度结合与封装大量的功能，所以实现起来并不是很复杂，像是socket的超时只需要一两个语句即可控制，也是非常简单方便，当然要实现更多的底层功能就需要掌握更多c#语言</p><p>这短暂时间的练习仅仅能掌握一些简单的c#语言，要想更深一步完善系统可能需要更仔细的掌握c#的一些深层次的用法</p><p>通过这次实验，我掌握了c#的socket编程，简单的多线程编程，以及c#调用外部exe程序的编程，另外对http以及cgi也有一定的理解与体会，掌握了较多未接触的新知识，但是还是比较简单的理解，如果真的要摸透c#在网络编程方面的更多细节部分依然需要很长时间的学习与掌握，在实验过后也有待自我学习与提升</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_494684" href="http://my.oschina.net/tmj1993/blog/494684">C#-JudgeSystem判题系统-判题系统</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-08-19 17:15:09</div>
	  <div class='catalog'>分类：JudgeSystem判题系统</div>
	  	  	  <div class='tags'>标签：C#,Server,编译,多线程,判题系统</div>	  	  	  </div>
      <div class='content'><p>运行环境: vs2013</p><p>框架: .net4.5</p><p>上一次实验已经完成了判题核心的封装，接下来就是通过服务器后台调用判题系统对客户端传来的数据进行判断</p><p>根据前面的一些测试我们建立新的解决方案来实现完整的判题系统</p><p>首先第一步我们先确定客户端和服务器的交互流程</p><p>客户端的数据有三个：源代码，输入，输出</p><p>这时候到底怎么传到服务器的，有两个方法，一个是一次性传输，一个是分三次传输</p><p>一次性传输的话就要面临怎么切割这三种数据，必须定义一个分割符，而且数据也要面临转义的问题，到了服务器也需要进行解译，这样会消耗一定的资源</p><p>但到底这三个数据是不是一定要一次性传输呢？其实并不用，因为这三个数据作用于不同阶段并且可以单独分割开来，所以分三次传输其实是可以的，并且每个阶段都可以根据回传来判断判题的状态，出现错误是可以减少后面两次的传输，节省一定的宽带与内存</p><p>server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cilent</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;send:源代码</p><p>read:源代码</p><p>compile:源代码</p><p>send:编译结果</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;read:编译情况</p><p><span style="line-height: 22.5px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>如果成功</p><p><span style="line-height: 22.5px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>send:输入</p><p>read:输入</p><p>run:输入</p><p>send:运行情况</p><p><span style="line-height: 22.5px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span> read:运行情况</p><p><span style="line-height: 22.5px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span> 如果程序成功运行结束未超时</p><p><span style="line-height: 22.5px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>send:输出</p><p>read:输出</p><p>比较输出</p><p>send:结果</p><p><span style="line-height: 22.5px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span> read:结果</p><p>close<span style="line-height: 22.5px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>close</p><p>做好流程设计后开始编码程序</p><p>由于把输入输出分离，所以类库接口需要改变适配，类库改变的成本较低，所以不采用改变调用</p><p><a href="http://static.oschina.net/uploads/img/201508/19171424_rr0R.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804134628" alt="Unnamed QQ Screenshot20150804134628" src="http://static.oschina.net/uploads/img/201508/19171425_KgMN.png" width="375" height="191"></a></p><p>分割实现</p><p><a href="http://static.oschina.net/uploads/img/201508/19171425_pXEn.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804165614" alt="Unnamed QQ Screenshot20150804165614" src="http://static.oschina.net/uploads/img/201508/19171425_1Eon.png" width="412" height="207"></a></p><p>第一步服务器读取源代码</p><p>编译，根据返回值来发送结果</p><p><a href="http://static.oschina.net/uploads/img/201508/19171426_q6Y1.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804165842" alt="Unnamed QQ Screenshot20150804165842" src="http://static.oschina.net/uploads/img/201508/19171426_cR4W.png" width="466" height="219"></a></p><p>如果编译通过就继续向客户端读取测试输入</p><p>考虑到部分程序不需要输入所以接收到\r\n则当作无输入</p><p>所以不允许程序只那\r\n来作为测试输入，事实上也没什么意义这样的输入</p><p>虽然可以再增加一次交互来确定程序是否提供无输入测试，但这里并没有做这个操作</p><p><a href="http://static.oschina.net/uploads/img/201508/19171427_uhVo.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804170611" alt="Unnamed QQ Screenshot20150804170611" src="http://static.oschina.net/uploads/img/201508/19171427_ZnHB.png" width="444" height="203"></a></p><p>如果能拿到结果不超时，则向客户端读取结果进行匹配</p><p>下面建立一个测试用的客户端项目</p><p><a href="http://static.oschina.net/uploads/img/201508/19171428_xXMD.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804170807" alt="Unnamed QQ Screenshot20150804170807" src="http://static.oschina.net/uploads/img/201508/19171428_ZJk8.png" width="569" height="362"></a></p><p>客户端三次大循环往服务器发送消息</p><p>运行服务器，监听8080端口</p><p><a href="http://static.oschina.net/uploads/img/201508/19171429_Ho79.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804171013" alt="Unnamed QQ Screenshot20150804171013" src="http://static.oschina.net/uploads/img/201508/19171429_an1z.png" width="201" height="89"></a></p><p>然后打开客户端进行连接</p><p><a href="http://static.oschina.net/uploads/img/201508/19171429_nj3U.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804171106" alt="Unnamed QQ Screenshot20150804171106" src="http://static.oschina.net/uploads/img/201508/19171430_KK1Q.png" width="255" height="228"></a></p><p>然后打开客户端进行连接</p><p><a href="http://static.oschina.net/uploads/img/201508/19171430_QQyt.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804171106" alt="Unnamed QQ Screenshot20150804171106" src="http://static.oschina.net/uploads/img/201508/19171431_0fnh.png" width="255" height="228"></a></p><p>设置了30秒的超时</p><p>过了30秒客户端无发送数据的话，会主动关闭连接</p><p><a href="http://static.oschina.net/uploads/img/201508/19171431_03SW.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804171150" alt="Unnamed QQ Screenshot20150804171150" src="http://static.oschina.net/uploads/img/201508/19171433_qBTh.png" width="652" height="339"></a></p><p>再次启动新的客户端测试</p><p><a href="http://static.oschina.net/uploads/img/201508/19171433_ysx0.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804171503" alt="Unnamed QQ Screenshot20150804171503" src="http://static.oschina.net/uploads/img/201508/19171434_jhYJ.png" width="459" height="434"></a></p><p>语法错误的测试，会返回客户端1，代表false</p><p><a href="http://static.oschina.net/uploads/img/201508/19171435_PmjD.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804171603" alt="Unnamed QQ Screenshot20150804171603" src="http://static.oschina.net/uploads/img/201508/19171436_QQVE.png" width="449" height="408"></a></p><p>没有语法错误编译通过的则返回0</p><p><a href="http://static.oschina.net/uploads/img/201508/19171437_rCFi.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804171916" alt="Unnamed QQ Screenshot20150804171916" src="http://static.oschina.net/uploads/img/201508/19171437_rx6R.png" width="254" height="369"></a></p><p>测试第一部分通过则测试第二部分，输入部分，源程序应该输入两个数字空格，输出两个数字的和，但测试中我只输入一个数字，5秒后程序还没结束则返回false，服务器端可以看出原因是超时</p><p>启动失败比较慢测试出来，还有一种可能是正常非正常退出</p><p><a href="http://static.oschina.net/uploads/img/201508/19171438_BlL3.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804172327" alt="Unnamed QQ Screenshot20150804172327" src="http://static.oschina.net/uploads/img/201508/19171438_Tb8O.png" width="239" height="365"></a></p><p>虽然输入是正确的，但是程序退出值不为0，当作错误处理，返回false</p><p>最后测试正确输出得到结果</p><p><a href="http://static.oschina.net/uploads/img/201508/19171439_AQ9S.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804172507" alt="Unnamed QQ Screenshot20150804172507" src="http://static.oschina.net/uploads/img/201508/19171439_u0XE.png" width="261" height="400"></a></p><p>虽然输入正确也能得到结果了，但是不匹配，则返回false</p><p><a href="http://static.oschina.net/uploads/img/201508/19171440_lE0w.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804172559" alt="Unnamed QQ Screenshot20150804172559" src="http://static.oschina.net/uploads/img/201508/19171440_XV2Y.png" width="230" height="393"></a></p><p>测试1+3=4可以通过，最后返回true，证明编译通过且结果正确</p><p>到此为止就完成了服务器程序的大部分功能了，而且异常机制与超时机制也可以保证服务器的运行</p><p>然后为了保证服务器的并发编译稳定性，测试程序将改成自动多线程并发执行判断结果是否通过</p><p>为了能遍历并发各种各样的情况，我把三个步骤的正确与错误做法写出用来做组合处理</p><p><a href="http://static.oschina.net/uploads/img/201508/19171441_zVFc.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804181746" alt="Unnamed QQ Screenshot20150804181746" src="http://static.oschina.net/uploads/img/201508/19171441_52Xa.png" width="918" height="209"></a></p><p>第一步，错误是少一个；分号</p><p><a href="http://static.oschina.net/uploads/img/201508/19171442_uYli.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804181752" alt="Unnamed QQ Screenshot20150804181752" src="http://static.oschina.net/uploads/img/201508/19171442_hu93.png" width="418" height="219"></a></p><p>第二步提供一下错误的输入</p><p><a href="http://static.oschina.net/uploads/img/201508/19171443_cicX.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804181758" alt="Unnamed QQ Screenshot20150804181758" src="http://static.oschina.net/uploads/img/201508/19171444_hnuk.png" width="403" height="204"></a></p><p>第三部提供错误的结果</p><p><a href="http://static.oschina.net/uploads/img/201508/19171444_hIU2.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804181804" alt="Unnamed QQ Screenshot20150804181804" src="http://static.oschina.net/uploads/img/201508/19171445_Stln.png" width="536" height="169"></a></p><p>check返回值，读取服务器的返回，0为true，1为false，每进行一步操作都要check一次看是否能匹配那次操作的返回值，不对应则为一次bug</p><p>线程函数已三个数字启动，做成字符串的形式</p><p>000代表三步为true</p><p>111代表第一步错误</p><p>011代表第二步错误</p><p>001代表第三步错误</p><p><a href="http://static.oschina.net/uploads/img/201508/19171445_1bQl.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804182418" alt="Unnamed QQ Screenshot20150804182418" src="http://static.oschina.net/uploads/img/201508/19171446_7Hi7.png" width="682" height="298"></a></p><p>启动线程遍历四种情况，每10次启动线程读取一次bug次数</p><p>并发间隔是500ms</p><p><a href="http://static.oschina.net/uploads/img/201508/19171447_CIke.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804182418" alt="Unnamed QQ Screenshot20150804182418" src="http://static.oschina.net/uploads/img/201508/19171448_RVm1.png" width="682" height="298"></a></p><p>启动线程遍历四种情况，每10次启动线程读取一次bug次数</p><p>并发间隔是500ms</p><p><a href="http://static.oschina.net/uploads/img/201508/19171450_7usV.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804181423 (1)" alt="Unnamed QQ Screenshot20150804181423 (1)" src="http://static.oschina.net/uploads/img/201508/19171452_YiWe.png" width="748" height="442"></a></p><p>放置启动700次线程，理论上大部分线程都完成操作，没有发现任何的bug</p><p>后来将并发速度提升到100ms</p><p>程序运行非常快，cpu占用也到了80%左右</p><p><a href="http://static.oschina.net/uploads/img/201508/19171454_ulSN.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804182714" alt="Unnamed QQ Screenshot20150804182714" src="http://static.oschina.net/uploads/img/201508/19171456_1W4l.png" width="814" height="407"></a></p><p>短时间运行下是没有任何的错误，服务器和客户端都没有崩溃</p><p>在进行上千次运算后</p><p>任务管理器中并没有发现游离的进程</p><p><a href="http://static.oschina.net/uploads/img/201508/19171458_k0N5.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804182926" alt="Unnamed QQ Screenshot20150804182926" src="http://static.oschina.net/uploads/img/201508/19171500_iRdT.png" width="466" height="472"></a></p><p>在测试路径下发现大量的编译程序</p><p>该测试证明，服务器系统是稳健的，高并发的，并且能提供准确返回值的系统</p><p>当然这次测试是在可靠的传输环境下实现的，而在不可靠环境下或者网络环境较差的情况下，服务器只能依赖于自身的超时检测，在30秒内客户端无消息则关闭连接</p><p>在完善服务器的情况下，我们继续实现客户端的GUI化</p><p>GUI部分简单复用一下原来第一个实验的代码，但需要增加输入输出框</p><p>简单修改一下</p><p><a href="http://static.oschina.net/uploads/img/201508/19171500_N1mu.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804185802" alt="Unnamed QQ Screenshot20150804185802" src="http://static.oschina.net/uploads/img/201508/19171501_gc4z.png" width="437" height="302"></a></p><p>里面一下控件有必要的写上变量名</p><p><a href="http://static.oschina.net/uploads/img/201508/19171501_6DNn.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804185833" alt="Unnamed QQ Screenshot20150804185833" src="http://static.oschina.net/uploads/img/201508/19171502_vDtK.png" width="305" height="213"></a></p><p>所幸的是textbox控件自带换行的功能，这个可以省去类似控制台的添加换行符的复杂问题，只需要将原来的控制台的程序代码复制一下，需要的数据改成从gui获取</p><p><a href="http://static.oschina.net/uploads/img/201508/19171502_M8Vc.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804190051" alt="Unnamed QQ Screenshot20150804190051" src="http://static.oschina.net/uploads/img/201508/19171503_hvfs.png" width="621" height="408"></a></p><p>点击ui上面的判题按钮会触发judge函数</p><p>完成后我们测试一下运行的效果</p><p>打开程序</p><p><a href="http://static.oschina.net/uploads/img/201508/19171504_CRWn.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804190234" alt="Unnamed QQ Screenshot20150804190234" src="http://static.oschina.net/uploads/img/201508/19171504_WwJr.png" width="430" height="300"></a></p><p>如果在没有源代码和输出的内容条件下，判题是不允许的</p><p><a href="http://static.oschina.net/uploads/img/201508/19171505_O2wk.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804190629" alt="Unnamed QQ Screenshot20150804190629" src="http://static.oschina.net/uploads/img/201508/19171505_e740.png" width="502" height="246"></a></p><p>无输入的判题(任意输入)</p><p><a href="http://static.oschina.net/uploads/img/201508/19171505_0bXD.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804190809" alt="Unnamed QQ Screenshot20150804190809" src="http://static.oschina.net/uploads/img/201508/19171506_kc19.png" width="430" height="300"></a></p><p>服务器关闭的情况下</p><p><a href="http://static.oschina.net/uploads/img/201508/19171507_QnTL.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804190913" alt="Unnamed QQ Screenshot20150804190913" src="http://static.oschina.net/uploads/img/201508/19171507_sjUY.png" width="430" height="300"></a></p><p>会显示服务器连接错误</p><p><a href="http://static.oschina.net/uploads/img/201508/19171509_go96.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804190957" alt="Unnamed QQ Screenshot20150804190957" src="http://static.oschina.net/uploads/img/201508/19171509_jq0r.png" width="430" height="300"></a></p><p>源代码少一个分号，显示编译错误</p><p><a href="http://static.oschina.net/uploads/img/201508/19171510_qp0K.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804191100" alt="Unnamed QQ Screenshot20150804191100" src="http://static.oschina.net/uploads/img/201508/19171511_5t1K.png" width="346" height="406"></a></p><p>不进行正确输入，服务器会显示超时处理，客户端会显示错误的输入</p><p><a href="http://static.oschina.net/uploads/img/201508/19171511_3hsT.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804191154" alt="Unnamed QQ Screenshot20150804191154" src="http://static.oschina.net/uploads/img/201508/19171512_wMqT.png" width="430" height="300"></a></p><p>输入正确则判断结果，结果不正确则输出错误的结果</p><p><a href="http://static.oschina.net/uploads/img/201508/19171512_N175.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150804191232" alt="Unnamed QQ Screenshot20150804191232" src="http://static.oschina.net/uploads/img/201508/19171513_JxO0.png" width="430" height="300"></a></p><p>结果正确，自然进入接受状态</p><p>对此已经完成客户端的基本功能，当然再错误的输入或者在算法复杂度较高的运算中，服务器未能够做出及时的相应，这时候就要做线程处理可以避免程序在等待过程中表现的卡死现象，暂时不去实现这是优化性的功能，到此整个实验已经进行完毕</p><p>通过最后一个综合实验，整合每个实验的内容，完善服务器功能与客户端的使用，在实验过程中，对于服务器的稳健性等做了更深层的探索，而客户端部分还有一些线程级别的优化并没有进行，有待实现，从开始的设计到各个部分的调整，也体会到知识综合应用的重要性，在这一次实验中并没有过多新知识的掌握，更重要的是接口与测试部分的实现</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_494677" href="http://my.oschina.net/tmj1993/blog/494677">C#-JudgeSystem判题系统-C#编译C程序</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-08-19 16:58:07</div>
	  <div class='catalog'>分类：JudgeSystem判题系统</div>
	  	  	  <div class='tags'>标签：C#,Server,编译,多线程,判题系统</div>	  	  	  </div>
      <div class='content'><p>运行环境: vs2013</p><p>框架: .net4.5</p><p>c编译器:mingw 32位</p><p>首先我们下载一个c编译工具链</p><p>http://tdm-gcc.tdragon.net/download</p><p>选择tmd gcc 32位编译器下载</p><p>配置好后我们就可以使用该编译器对c程序进行编程</p><p>尝试写个简单的c代码测试一下编译</p><p><a href="http://static.oschina.net/uploads/img/201508/19165718_p24b.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801133956" alt="Unnamed QQ Screenshot20150801133956" src="http://static.oschina.net/uploads/img/201508/19165719_USCP.png" width="280" height="182"></a></p><p>&amp;#160;</p><p>保存为test.c</p><p>通过工具链的gcc程序进行编译</p><p><a href="http://static.oschina.net/uploads/img/201508/19165720_Alfo.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801134328" alt="Unnamed QQ Screenshot20150801134328" src="http://static.oschina.net/uploads/img/201508/19165721_Oohz.png" width="651" height="102"></a></p><p>通过类似gnu gcc的方式进行编译</p><p>可以正确运行出结果</p><p>测试c编译器可用的情况下我们尝试使用c#进行外部调用</p><p>在原先的项目中添加ExeExecute项目</p><p>要调用外部的exe程序我们需要引入</p><p>using System.Diagnostics;</p><p>而要使用外部exe主要是掌握Process对象的使用</p><p>Process p = new Process();</p><p>而使用Process主要分为三个步骤，第一步是设定启动参数，第二步是启动exe程序，第三步是捕抓程序的输入输出流进行控制</p><p>然后第一步的参数设置:</p><p>确定编译器对象为gcc.exe</p><p>p.StartInfo.FileName = @"C:\Users\Administrator\Desktop\gcc-5.1.0\bin\gcc.exe";</p><p>gcc程序不在相同路径下需要使用完整路径</p><p>设定好程序路径我们还需要设定工作路径，也就是源代码以及生成程序代码的路径</p><p>p.StartInfo.WorkingDirectory = @"C:\Users\Administrator\Desktop\test\";</p><p>最后要设定编译参数</p><p>p.StartInfo.Arguments = "test.c -o test.exe -m32 -g3 -static-libgcc";</p><p>采用静态编译，因为部分dll并没有添加到系统环境变量中</p><p>最后为了能捕抓程序的输入输出流，我们不采用外部调用系统的shell，输入输出流重定向到程序中</p><p>p.StartInfo.UseShellExecute = false; &nbsp; <br>p.StartInfo.RedirectStandardOutput = true;</p><p>第二步程序运行</p><p>p.Start();</p><p>第三部捕抓输入输出</p><p>编译结果输出信息重定向到c#程序的控制台上</p><p>Console.Write(p.StandardOutput.ReadToEnd());</p><p>编译正常除了警告外是不会有其他输出信息的 &nbsp; <br>Console.WriteLine(p.ExitCode);</p><p>而程序退出码则是判断是否成功编译的关键</p><p>p.WaitForExit();</p><p>p.Close();</p><p>最后必须退出外部exe调用的程序，不然会无法控制一直运行在后台导致内存溢出</p><p>根据上面的步骤来综合编写程序</p><p><a href="http://static.oschina.net/uploads/img/201508/19165722_LOOh.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801174919" alt="Unnamed QQ Screenshot20150801174919" src="http://static.oschina.net/uploads/img/201508/19165724_2ygb.png" width="592" height="339"></a></p><p>很不幸运行程序过程中系统提示部分dll找不到，然后我尝试通过控制台来测试，甚至直接修改环境变量导入dll到系统中仍无法解决该问题</p><p>目前有两个解决方案，as.exe路径或者在程序运行目录下放置必要的dll文件</p><p>为了不破坏编译程序的结构，现采用复制到test目录下编译，虽然可以通过程序来建立临时路径来访问dll但会影响一定的速度，复制到目录中共享虽然影响一定的可移动性，但还是能更高效的使用，为后面并发编译做准备</p><p>接下来做测试，先测试正确编译的情况</p><p><a href="http://static.oschina.net/uploads/img/201508/19165724_F1FM.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801175318" alt="Unnamed QQ Screenshot20150801175318" src="http://static.oschina.net/uploads/img/201508/19165724_IO0z.png" width="232" height="97"></a></p><p>程序不提醒任何错误，显示编译成功</p><p>修改源代码制造语法错误</p><p><a href="http://static.oschina.net/uploads/img/201508/19165725_R3UR.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801175535" alt="Unnamed QQ Screenshot20150801175535" src="http://static.oschina.net/uploads/img/201508/19165725_rtFx.png" width="268" height="179"></a></p><p><a href="http://static.oschina.net/uploads/img/201508/19165727_8y1J.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801175614" alt="Unnamed QQ Screenshot20150801175614" src="http://static.oschina.net/uploads/img/201508/19165728_t2ZT.png" width="432" height="153"></a></p><p>编译会提示出错信息</p><p><a href="http://static.oschina.net/uploads/img/201508/19165729_Eaoz.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801175740" alt="Unnamed QQ Screenshot20150801175740" src="http://static.oschina.net/uploads/img/201508/19165730_cfG9.png" width="288" height="164"></a></p><p>再修改源代码</p><p><a href="http://static.oschina.net/uploads/img/201508/19165731_6Msd.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801175747" alt="Unnamed QQ Screenshot20150801175747" src="http://static.oschina.net/uploads/img/201508/19165732_R38u.png" width="567" height="132"></a></p><p>这次是可以编译成功，过程中的警告会有所显示</p><p>能成功编译程序后我们需要运行程序进行输入输出测试，这时候修改一下原程序</p><p><a href="http://static.oschina.net/uploads/img/201508/19165733_ziV4.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801180049" alt="Unnamed QQ Screenshot20150801180049" src="http://static.oschina.net/uploads/img/201508/19165735_ovpx.png" width="285" height="215"></a></p><p>先做出可以提供输入输出的程序进行编译</p><p>根据ExitCode判断编译成功后可以运行程序来进行测试</p><p><a href="http://static.oschina.net/uploads/img/201508/19165736_xo69.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150801180543" alt="Unnamed QQ Screenshot20150801180543" src="http://static.oschina.net/uploads/img/201508/19165736_hGg0.png" width="573" height="398"></a></p><p>&amp;#160;</p><p>接下来跟上面的外部调用一样，这次主要多开启了输入流重定向</p><p>p.StartInfo.RedirectStandardInput = true;</p><p>通过输入流以及读取输出流判断结果是否正确</p><p>这个程序并没有做泛化出来来适配各种各样的输入输出情况</p><p>接下来泛化一下，做出类库封装编译与测试功能</p><p><a href="http://static.oschina.net/uploads/img/201508/19165738_irNM.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803164406" alt="Unnamed QQ Screenshot20150803164406" src="http://static.oschina.net/uploads/img/201508/19165740_J5UE.png" width="955" height="582"></a></p><p>建立编译测试类库</p><p>该类库主要包含编译与测试两部分</p><p>然后我们定义一些类库的接口</p><p>构造函数有两个</p><p>默认不带参数的构造方法，提供默认的gcc可执行路径，以及c文件编译测试的工具路径</p><p><a href="http://static.oschina.net/uploads/img/201508/19165742_iZWi.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803174433" alt="Unnamed QQ Screenshot20150803174433" src="http://static.oschina.net/uploads/img/201508/19165743_j94G.png" width="316" height="93"></a></p><p>另外一个是指定参数构建，可以方便非相对路径下的使用</p><p><a href="http://static.oschina.net/uploads/img/201508/19165744_keBK.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803174503" alt="Unnamed QQ Screenshot20150803174503" src="http://static.oschina.net/uploads/img/201508/19165744_rkgb.png" width="413" height="76"></a></p><p>下一步是编译方法</p><p>编译需要c源文件代码，返回是否成功编译</p><p>public bool Compile(string csrccode);</p><p>方法中需要先保存为*.c来编译</p><p>因为考虑到后面的并发编译，这个文件名不得与其他的线程重复，避免出现资源占用的错误以及对结果的影响</p><p>而文件是跟线程共存亡的，线程结束该文件就无用了</p><p>所以文件名依赖于线程</p><p>string testID = Thread.CurrentThread.ManagedThreadId.ToString();</p><p>通过获取线程id作为文件名，可以保证不会影响其他进程的运行，如果通过加锁的方式来并发反而会影响效率</p><p>&amp;#160;</p><p><a href="http://static.oschina.net/uploads/img/201508/19165745_Qg3E.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803184622" alt="Unnamed QQ Screenshot20150803184622" src="http://static.oschina.net/uploads/img/201508/19165746_1XPA.png" width="455" height="286"></a></p><p>写入文件，结合上面掌握的一些代码，来编写，这时候一些调试性代码可以关闭，不用在控制台输出影响效率</p><p><a href="http://static.oschina.net/uploads/img/201508/19165747_QuoX.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803184645" alt="Unnamed QQ Screenshot20150803184645" src="http://static.oschina.net/uploads/img/201508/19165748_Q0Wr.png" width="677" height="325"></a></p><p>接下来就要运行程序来判断输入输出流</p><p>先运行程序</p><p><a href="http://static.oschina.net/uploads/img/201508/19165749_MqWn.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803184720" alt="Unnamed QQ Screenshot20150803184720" src="http://static.oschina.net/uploads/img/201508/19165749_L2ls.png" width="466" height="305"></a></p><p>运行等待输入输出操作</p><p><a href="http://static.oschina.net/uploads/img/201508/19165750_YA1l.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803184834" alt="Unnamed QQ Screenshot20150803184834" src="http://static.oschina.net/uploads/img/201508/19165750_r6TP.png" width="287" height="155"></a></p><p>析构时候需要做关闭操作避免后台运行没有正常关闭导致内存异常</p><p><a href="http://static.oschina.net/uploads/img/201508/19165750_I23v.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803184935" alt="Unnamed QQ Screenshot20150803184935" src="http://static.oschina.net/uploads/img/201508/19165751_CSWV.png" width="443" height="232"></a></p><p>输出，结果配对，不匹配返回false，匹配返回true</p><p><a href="http://static.oschina.net/uploads/img/201508/19165751_Ugod.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803185117" alt="Unnamed QQ Screenshot20150803185117" src="http://static.oschina.net/uploads/img/201508/19165752_claM.png" width="468" height="212"></a></p><p>输入部分，判断程序是否已经退出了(退出不关闭依旧可以正常输入流)</p><p><a href="http://static.oschina.net/uploads/img/201508/19165753_RwIy.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803185222" alt="Unnamed QQ Screenshot20150803185222" src="http://static.oschina.net/uploads/img/201508/19165754_qMYn.png" width="349" height="331"></a></p><p>结束判断，如果程序还在运行中证明缺少输入或者输出，不能完全匹配测试，返回错误，关闭程序</p><p><a href="http://static.oschina.net/uploads/img/201508/19165754_JpWC.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803191338" alt="Unnamed QQ Screenshot20150803191338" src="http://static.oschina.net/uploads/img/201508/19165754_BHZO.png" width="487" height="162"></a></p><p>虽然尝试使用c++类似的输入输出流的重载，但是返回对象时候不能返回引用对象，要是new对象，可能我写法上有问题导致无法很好地重载，不然可以连续做输入输出判断，错误通过异常抛出的操作，现在暂时不成功</p><p>编写完成就开始测试</p><p><a href="http://static.oschina.net/uploads/img/201508/19165755_iyq3.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803191620" alt="Unnamed QQ Screenshot20150803191620" src="http://static.oschina.net/uploads/img/201508/19165755_uVkJ.png" width="220" height="61"></a></p><p>引用类库</p><p><a href="http://static.oschina.net/uploads/img/201508/19165755_K7q9.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803191650" alt="Unnamed QQ Screenshot20150803191650" src="http://static.oschina.net/uploads/img/201508/19165756_Z6xp.png" width="1002" height="24"></a></p><p>对象new</p><p><a href="http://static.oschina.net/uploads/img/201508/19165757_0g7c.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803191719" alt="Unnamed QQ Screenshot20150803191719" src="http://static.oschina.net/uploads/img/201508/19165758_97Ir.png" width="672" height="23"></a></p><p>测试一下简单的hello world</p><p><a href="http://static.oschina.net/uploads/img/201508/19165759_griZ.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803191747" alt="Unnamed QQ Screenshot20150803191747" src="http://static.oschina.net/uploads/img/201508/19165759_3wnL.png" width="416" height="153"></a></p><p>判断代码，判断输出一次hello world!再输入一次hello world!</p><p><a href="http://static.oschina.net/uploads/img/201508/19165800_FnEw.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803191808" alt="Unnamed QQ Screenshot20150803191808" src="http://static.oschina.net/uploads/img/201508/19165801_tD4q.png" width="110" height="130"></a></p><p>结果是错误的因为我多输入了一次无效的操作</p><p>注释掉无效的操作后</p><p><a href="http://static.oschina.net/uploads/img/201508/19165801_9fvF.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803191911" alt="Unnamed QQ Screenshot20150803191911" src="http://static.oschina.net/uploads/img/201508/19165801_wCd0.png" width="99" height="116"></a></p><p>运行成功</p><p>#include&lt;stdio.h&gt;</p><p>int main(){</p><p>int a,b;</p><p>printf("input two number:\n");</p><p>scanf("%d %d",&amp;a,&amp;b);</p><p>printf("res:%d",a + b);</p><p>return 0;</p><p>}</p><p>第二次我用输出输入输出的方式，然后验证的时候在读取第一个输入的时候无法读取，用read方法也好，readline也好，readtoend也好，都是不能读取数据，只会阻塞等待，所以程序只能不断输入，再一次性输出，这会导致系统只能有一次流完整读取操作。</p><p><a href="http://static.oschina.net/uploads/img/201508/19165802_HsLQ.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803195952" alt="Unnamed QQ Screenshot20150803195952" src="http://static.oschina.net/uploads/img/201508/19165803_kaek.png" width="506" height="225"></a></p><p>运行</p><p><a href="http://static.oschina.net/uploads/img/201508/19165803_E6vS.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803200026" alt="Unnamed QQ Screenshot20150803200026" src="http://static.oschina.net/uploads/img/201508/19165803_GyDQ.png" width="111" height="117"></a></p><p>卡在第一次读取输出流中</p><p>这意味着程序无法输入输出按次判断，只能完整输入判断输出</p><p><a href="http://static.oschina.net/uploads/img/201508/19165804_NUFG.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803200138" alt="Unnamed QQ Screenshot20150803200138" src="http://static.oschina.net/uploads/img/201508/19165804_FJ6O.png" width="447" height="87"></a></p><p>修改只有一次写入一次读取</p><p><a href="http://static.oschina.net/uploads/img/201508/19165805_RD98.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803200204" alt="Unnamed QQ Screenshot20150803200204" src="http://static.oschina.net/uploads/img/201508/19165805_1QcN.png" width="121" height="130"></a></p><p>此时可以看到正确的结果</p><p>由于原先的猜想无法成立，现在简化代码单纯完成输入输出检测不进行顺序检测</p><p>最后通过public bool RunTest(string exein,string exeout)进行判断</p><p><a href="http://static.oschina.net/uploads/img/201508/19165806_sDTI.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803211510" alt="Unnamed QQ Screenshot20150803211510" src="http://static.oschina.net/uploads/img/201508/19165806_qoQ7.png" width="525" height="366"></a></p><p>同样是刚才那份代码</p><p><a href="http://static.oschina.net/uploads/img/201508/19165807_gzdM.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803211545" alt="Unnamed QQ Screenshot20150803211545" src="http://static.oschina.net/uploads/img/201508/19165807_rt0m.png" width="447" height="120"></a></p><p><a href="http://static.oschina.net/uploads/img/201508/19165808_wXq0.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803211612" alt="Unnamed QQ Screenshot20150803211612" src="http://static.oschina.net/uploads/img/201508/19165808_KgEk.png" width="117" height="110"></a></p><p>运行一下可以通过</p><p>接下来有一句容易导致超时的语句要进行处理</p><p>exeRun.StandardOutput.ReadToEnd();</p><p>因为readtoend可能由于死循环，等待输出等原因阻塞或者卡死，不作超时处理会有大量的死掉的进程，而且还无法给客户端及时的信息反馈</p><p>这时候我们就要单独对这个语句做一个超时处理</p><p>先做一个时间处理</p><p>ManualResetEvent timeEvent = new ManualResetEvent(false);</p><p><a href="http://static.oschina.net/uploads/img/201508/19165809_vAzi.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803214531" alt="Unnamed QQ Screenshot20150803214531" src="http://static.oschina.net/uploads/img/201508/19165809_LNp4.png" width="589" height="183"></a></p><p>建立委托，完成任务着set一下事件</p><p>然后主进程会异步调用改委托</p><p>proc.BeginInvoke(null, null, null);</p><p>bool flag = timeEvent.WaitOne(time, false);</p><p>然后线程在等待时间内不断检测是否改变timeEvent标志</p><p>改变了的话里面返回true</p><p>否则会超时后为false</p><p>如果超时常规退出不是行的了</p><p><a href="http://static.oschina.net/uploads/img/201508/19165810_fQng.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803215033" alt="Unnamed QQ Screenshot20150803215033" src="http://static.oschina.net/uploads/img/201508/19165810_yzcE.png" width="314" height="116"></a></p><p>只能kill掉死掉的进程</p><p><a href="http://static.oschina.net/uploads/img/201508/19165811_X4sb.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150803215124" alt="Unnamed QQ Screenshot20150803215124" src="http://static.oschina.net/uploads/img/201508/19165811_HLLE.png" width="484" height="80"></a></p><p>为了实现超时时间的可控性，为runtest函数重载</p><p>增加一个timeout参数可以应对算法较复杂的程序，类内默认初始值为5000ms</p><p>然后进行测试确定可用，准备用于下一个综合实验</p><p>通过该实验我掌握了exe的外部调用，以及对输入输出流的读写控制，以及gcc编译器工具在windows下的编译使用的方法，以及不断修改到最后做出可超时检测的c编译器调用与程序测试的程序，由于技术知识缺少，暂时未能解决对输入输出的步骤控制</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_494667" href="http://my.oschina.net/tmj1993/blog/494667">C#-JudgeSystem判题系统-客户端和多线程</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-08-19 16:44:16</div>
	  <div class='catalog'>分类：JudgeSystem判题系统</div>
	  	  	  <div class='tags'>标签：C#,Server,编译,多线程,判题系统</div>	  	  	  </div>
      <div class='content'><p>&amp;#160;</p><p>运行环境: vs2013</p><p>框架: .net4.5</p><p>上次实验中已经实现了单线程下的socket的tcp服务器</p><p>由于使用浏览器并不能直观的显示socket之间的交互相应，所以这次实验我们先完成客户端部分的编程再进行服务端编程的完善</p><p>同样的先建立好一个新的项目</p><p><a href="http://static.oschina.net/uploads/img/201508/19164341_utYM.jpg" rel="nofollow"><img title="d000baa1cd11728b45647b06cafcc3cec3fd2c4c" alt="d000baa1cd11728b45647b06cafcc3cec3fd2c4c" src="http://static.oschina.net/uploads/img/201508/19164343_i4jJ.jpg" width="489" height="498"></a></p><p>客户端部分需要两个操作才能成功连接</p><p>套接字建立部分与服务端一致</p><p>Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</p><p>然后就是进入连接部分</p><p>先建立待连接的ip与端口对象</p><p>IPEndPoint ipe = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 7777);</p><p>s.Connect(ipe);</p><p>知道这些后我们编程实现一下连接功能</p><p><a href="http://static.oschina.net/uploads/img/201508/19164346_YdEp.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730172451" alt="Unnamed QQ Screenshot20150730172451" src="http://static.oschina.net/uploads/img/201508/19164347_f00j.png" width="636" height="117"></a></p><p>编码完成进行一下测试，先启动我们的server程序等待连接</p><p>再打开client程序请求连接</p><p><a href="http://static.oschina.net/uploads/img/201508/19164348_6ioc.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730172606" alt="Unnamed QQ Screenshot20150730172606" src="http://static.oschina.net/uploads/img/201508/19164348_t94z.png" width="241" height="168"></a></p><p>此时我们观察到两个程序直接已经通过socket建立通信</p><p>此时再完善客户端的读写操作</p><p>对于客户端而已读写操作跟服务端是没有任何区别的，本质是这个阶段并不区分客户端与服务端，其读写是对等的</p><p>s.Send(buf, buf.Length, SocketFlags.None); &nbsp; <br>bytes = s.Receive(buf, buf.Length, SocketFlags.None);</p><p>发送与接收</p><p><a href="http://static.oschina.net/uploads/img/201508/19164348_W5PP.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730173607" alt="Unnamed QQ Screenshot20150730173607" src="http://static.oschina.net/uploads/img/201508/19164349_rpnx.png" width="452" height="193"></a></p><p>确定没问题后我们进行测试，测试方法同上</p><p><a href="http://static.oschina.net/uploads/img/201508/19164350_AnEe.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730173648" alt="Unnamed QQ Screenshot20150730173648" src="http://static.oschina.net/uploads/img/201508/19164350_zFyk.png" width="295" height="268"></a></p><p>上面是服务端下面是客户端</p><p>过程中客户端发送接受一次数据，服务端接受发送一次数据</p><p>由于服务器部分并没有使用多线程的设置导致该程序不能同时连接多个客户端，这时候我们需要把服务器的Accept()方法放入线程中，通过while(true)方式循环多次接受客户端的连接，为了能更快的处理客户端的一次连接，以及处理长时间连接的客户端，还虽然再产生新的线程去处理接收和发送部分的工作</p><p>确定设计思路后我们先引入线程的引用部分</p><p>using System.Threading;&amp;#160;</p><p>对原先的代码该如何修改呢</p><p>首先要修改最大连接数</p><p>s.Listen(10);//代表最大可提供10个连接队列</p><p>然后原本Socket temp = s.Accept();放入线程中处理</p><p>这时候就要建立一个线程函数</p><p><a href="http://static.oschina.net/uploads/img/201508/19164350_O0XX.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731142114" alt="Unnamed QQ Screenshot20150731142114" src="http://static.oschina.net/uploads/img/201508/19164351_yeId.png" width="586" height="155"></a></p><p>需要传入服务器的socket对象，循环接受对象的连接，暂时未处理读写部分</p><p>Thread listen = new Thread(Listen); &nbsp; <br>listen.Start(s);</p><p>主函数中创建线程与带server对象的启动线程</p><p>注释掉之前的代码</p><p><a href="http://static.oschina.net/uploads/img/201508/19164352_ayOe.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731142311" alt="Unnamed QQ Screenshot20150731142311" src="http://static.oschina.net/uploads/img/201508/19164352_n4Bo.png" width="666" height="460"></a></p><p>然后测试一下是否能多个进程连接到该服务器</p><p><a href="http://static.oschina.net/uploads/img/201508/19164357_8x39.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731142535" alt="Unnamed QQ Screenshot20150731142535" src="http://static.oschina.net/uploads/img/201508/19164358_RKUP.png" width="597" height="311"></a></p><p>四个单独的客户端都可以连接到服务器，由于服务器并没有做接收和发送处理，客户端都处于阻塞状态等待数据接收</p><p>接下来处理服务端的数据接收与发生</p><p><a href="http://static.oschina.net/uploads/img/201508/19164358_eLXU.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731143228" alt="Unnamed QQ Screenshot20150731143228" src="http://static.oschina.net/uploads/img/201508/19164359_DHoc.png" width="466" height="259"></a></p><p>创建一个用于线程的函数，其中只是简单复制一下前面的发送接收的代码用于测试</p><p><a href="http://static.oschina.net/uploads/img/201508/19164359_a0mx.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731143624" alt="Unnamed QQ Screenshot20150731143624" src="http://static.oschina.net/uploads/img/201508/19164359_NUki.png" width="598" height="183"></a></p><p>在原来的监听线程上，创建一个数据的接收与发生线程用于跟客户端连接，实际上客户端可能需要一个长连接多次处理数据，如果都放入监听线程中处理会影响下一个客户端的连接</p><p><a href="http://static.oschina.net/uploads/img/201508/19164359_DqrH.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731143624" alt="Unnamed QQ Screenshot20150731143624" src="http://static.oschina.net/uploads/img/201508/19164400_l6ZP.png" width="598" height="183"></a></p><p>尝试对三个客户端同时连接，皆成功连接，但实际上我手动操作并不能体现客户端的高并发的效果，这事我们尝试修改客户端线程并发连接服务器看起是否能正常使用</p><p>在客户端主线程中</p><p><a href="http://static.oschina.net/uploads/img/201508/19164400_6fxn.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731145252" alt="Unnamed QQ Screenshot20150731145252" src="http://static.oschina.net/uploads/img/201508/19164400_TTZR.png" width="352" height="95"></a></p><p>只加入一个循环的线程客户端创建</p><p>并且每创建一个阻塞10ms防止客户端过多导致内存溢出</p><p><a href="http://static.oschina.net/uploads/img/201508/19164401_a8ZL.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731145438" alt="Unnamed QQ Screenshot20150731145438" src="http://static.oschina.net/uploads/img/201508/19164402_hBQB.png" width="540" height="464"></a></p><p>线程函数里面复制原来的客户端代码，并加入异常处理防止出错程序退出</p><p><a href="http://static.oschina.net/uploads/img/201508/19164403_c3Tz.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731145553" alt="Unnamed QQ Screenshot20150731145553" src="http://static.oschina.net/uploads/img/201508/19164403_p99X.png" width="736" height="432"></a></p><p>运行程序我们可以看到客户端与服务器快速连接</p><p><a href="http://static.oschina.net/uploads/img/201508/19164408_Y3nr.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731145711" alt="Unnamed QQ Screenshot20150731145711" src="http://static.oschina.net/uploads/img/201508/19164410_7d9T.png" width="1053" height="552"></a></p><p>启动两个客户端并发操作会出现大量的服务器拒绝连接，因为同一时间服务器仅仅提供指定数量的客户端连接，所以大规模的并发会有部分客户端无法成功连接而抛出异常</p><p>对此我们完成了客户端与服务端的并发多线程处理，下面我们尝试客户端长连接服务器并提交请求</p><p>对于http协议而言有个http请求头</p><p>Connection: Keep-Alive</p><p>这个请求头决定服务器是否提供长连接还是返回数据后立马断开连接，对于请求多个静态文件的网页比较有效的减少连接次数，但是也会造成性能的降低，必须设定超时并在那段时间内消耗不必要的系统资源</p><p>接下来我们要做一个能够通过浏览器访问的服务器</p><p><a href="http://static.oschina.net/uploads/img/201508/19164410_91nt.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731155333" alt="Unnamed QQ Screenshot20150731155333" src="http://static.oschina.net/uploads/img/201508/19164411_YlQV.png" width="589" height="139"></a></p><p>首先我们来观察一次http请求浏览器到底给我们服务器发送了什么数据呢</p><p>通过fiddler观察到其数据的内容</p><p>有多个请求内容，由于我们只做一个简单可用的服务器，暂时忽略一些较为复杂的扩展处理功能，只针对get方法进行处理</p><p>string[] split = str.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);</p><p>首先第一步对从客户端接收到的数据中获取http头请求信息，再通过\r\n分割信息</p><p><a href="http://static.oschina.net/uploads/img/201508/19164411_3G7d.png" rel="nofollow"><img title="1" alt="1" src="http://static.oschina.net/uploads/img/201508/19164412_Sf2s.png" width="1014" height="200"></a></p><p>通过断点跟踪可以看到具体的内容，取get中的请求内容再切割</p><p>string[] get = split[0].Split(new Char[] { ' '});</p><p>可以拿到具体的网页请求字符串</p><p><a href="http://static.oschina.net/uploads/img/201508/19164412_2vRz.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731160507" alt="Unnamed QQ Screenshot20150731160507" src="http://static.oschina.net/uploads/img/201508/19164413_F2hm.png" width="870" height="312"></a></p><p>这里头我们尝试假设了几个不同的静态文件，index首页文件，css文件，已经两种不同的响应头</p><p>然后在程序中</p><p><a href="http://static.oschina.net/uploads/img/201508/19164413_VNY4.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731160639" alt="Unnamed QQ Screenshot20150731160639" src="http://static.oschina.net/uploads/img/201508/19164414_zCp3.png" width="466" height="274"></a></p><p>根据不同的请求，提供相应的返回内容，非正常请求返回404错误</p><p>然后进行超时处理</p><p>temp.ReceiveTimeout = 500;</p><p>可以对socket的接收设定超时值500ms，只要接收到数据到下一次接收之间时间差距不超过500ms就可以不断开连接，对于少静态文件的网页可能不明显，但是对于多静态文件的网站可以有效减少重复连接次数</p><p><a href="http://static.oschina.net/uploads/img/201508/19164414_yM0g.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731161003" alt="Unnamed QQ Screenshot20150731161003" src="http://static.oschina.net/uploads/img/201508/19164414_XPD4.png" width="338" height="186"></a></p><p>超时会进入异常，关闭套接字，其他异常则捕抓输出</p><p><a href="http://static.oschina.net/uploads/img/201508/19164415_H277.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731161233" alt="Unnamed QQ Screenshot20150731161233" src="http://static.oschina.net/uploads/img/201508/19164415_lUE0.png" width="251" height="242"></a></p><p>但是实际使用浏览器的过程中，浏览器依然是发起了三次连接，一个是请求首页文件，另一个的通过首页文件触发连接请求css文件，最后一个是chrome自身对网站图标的请求，该请求被忽略返回404</p><p><a href="http://static.oschina.net/uploads/img/201508/19164415_xIN7.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731161458" alt="Unnamed QQ Screenshot20150731161458" src="http://static.oschina.net/uploads/img/201508/19164416_ozOb.png" width="952" height="99"></a></p><p>通过chrome我们可以看到请求情况</p><p><a href="http://static.oschina.net/uploads/img/201508/19164416_QDLb.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731161530" alt="Unnamed QQ Screenshot20150731161530" src="http://static.oschina.net/uploads/img/201508/19164416_mpxr.png" width="733" height="125"></a></p><p>运行效果等</p><p>使用ie是只请求两次并关闭两次连接，在请求第二次前第一次的连接并没有关闭，对此有点疑惑，也许是我理解有所偏差</p><p>fiddler也能跟踪到数据的收发</p><p><a href="http://static.oschina.net/uploads/img/201508/19164417_5X11.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731161749" alt="Unnamed QQ Screenshot20150731161749" src="http://static.oschina.net/uploads/img/201508/19164417_lNz2.png" width="184" height="57"></a></p><p><a href="http://static.oschina.net/uploads/img/201508/19164417_HduC.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731161754" alt="Unnamed QQ Screenshot20150731161754" src="http://static.oschina.net/uploads/img/201508/19164418_fMqY.png" width="755" height="47"></a></p><p>可以证明该服务器可以正确相应简单的http请求已经多线程实现</p><p>最后修改客户端来模仿ie请求http</p><p><a href="http://static.oschina.net/uploads/img/201508/19164419_4b1d.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731163445" alt="Unnamed QQ Screenshot20150731163445" src="http://static.oschina.net/uploads/img/201508/19164419_vIEA.png" width="464" height="406"></a></p><p>&amp;#160;</p><p>主要是将请求的字符串修改为标准的http头</p><p>这里只请求127.0.0.1:7777/的内容</p><p>也就是服务器的index文件</p><p>由于服务器并没有提供其他更为高级的功能这里就不写过多的请求头了</p><p>接收部分要重复多次接收才能完全读取所有的服务器返回数据</p><p><a href="http://static.oschina.net/uploads/img/201508/19164420_8eDl.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150731163704" alt="Unnamed QQ Screenshot20150731163704" src="http://static.oschina.net/uploads/img/201508/19164420_FFtO.png" width="237" height="272"></a></p><p>成功获取服务器的html文本</p><p>也可以并发获取文本信息</p><p>通过该实验我掌握了socket编程的一些更高级的用法，通过多线程来实现对客户端的请求处理，通过从客户端获取的请求字符串来反馈信息，同步处理信息等，在异步处理上仍有待学习，对于并发过程中出现一些错误有所不理解，仍有待研究，通过该实验对网络编程的理解有所提高。</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_494573" href="http://my.oschina.net/tmj1993/blog/494573">C#-JudgeSystem判题系统-一个简单的HTTPServer</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-08-19 14:52:18</div>
	  <div class='catalog'>分类：JudgeSystem判题系统</div>
	  	  	  <div class='tags'>标签：C#,Server,编译,多线程,判题系统</div>	  	  	  </div>
      <div class='content'><p>在原来的HTTPServer项目解决方案中添加新的控制台SocketServer项目</p><p><a href="http://static.oschina.net/uploads/img/201508/19145134_qS4t.png" rel="nofollow"><img title="1" alt="1" src="http://static.oschina.net/uploads/img/201508/19145135_B7YX.png" width="824" height="540"></a></p><p>添加新的项目后可以看到解决方案中有两个项目</p><p><a href="http://static.oschina.net/uploads/img/201508/19145136_6cvH.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729194308" alt="Unnamed QQ Screenshot20150729194308" src="http://static.oschina.net/uploads/img/201508/19145139_kJ51.png" width="218" height="262"></a></p><p>建立好项目后我们可以进行编程</p><p>进行编程前我们需要了解c# socket编程以及http的规范</p><p>1.socket编程</p><p><a href="http://static.oschina.net/uploads/img/201508/19145141_5qBy.jpg" rel="nofollow"><img title="d000baa1cd11728b45647b06cafcc3cec3fd2c4c" alt="d000baa1cd11728b45647b06cafcc3cec3fd2c4c" src="http://static.oschina.net/uploads/img/201508/19145143_yh2Y.jpg" width="489" height="498"></a></p><p>首先我们决定使用tcp协议，拿到一张socket的tcp连接过程</p><p>第一个建立一个c# socket套接字对象：</p><p>Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</p><p>其中对象构造函数需要传入三个对象用于建立合适的socket连接</p><p>AddressFamily.InterNetwork代表使用ipv4协议</p><p>SocketType.Stream基于流</p><p>ProtocolType.Tcp协议为TCP</p><p>建立socket对象后我们需要绑定ip和端口:</p><p>ip使用0.0.0.0作为监听端口</p><p>port使用7777作为监听端口</p><p>IPEndPoint ipe = new IPEndPoint(IPAddress.Parse("0.0.0.0"), 7777);</p><p>第三步是注册监听端口:</p><p>s.Listen(0);</p><p>第四步是进入接受状态:</p><p>Socket temp = s.Accept();</p><p>此时程序阻塞等待客户端连接</p><p>连接成功程序才能继续执行</p><p><a href="http://static.oschina.net/uploads/img/201508/19145144_mG3q.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730162150" alt="Unnamed QQ Screenshot20150730162150" src="http://static.oschina.net/uploads/img/201508/19145146_Y70m.png" width="662" height="168"></a></p><p>目前处理好socket的建立与连接，我们测试一下代码是否能正确连接再进行读写的操作，通过右侧项目设置为启动项目</p><p><a href="http://static.oschina.net/uploads/img/201508/19145147_Sjor.png" rel="nofollow"><img title="2" alt="2" src="http://static.oschina.net/uploads/img/201508/19145150_Cc3u.png" width="486" height="282"></a></p><p>程序运行</p><p><a href="http://static.oschina.net/uploads/img/201508/19145152_LF9J.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730162215" alt="Unnamed QQ Screenshot20150730162215" src="http://static.oschina.net/uploads/img/201508/19145153_fltM.png" width="253" height="121"></a></p><p>我们看到系统监听着0.0.0.0:7777</p><p>由于浏览器充当客户端的角色，我们只需要再浏览器中访问127.0.0.1:7777</p><p>&amp;#160;</p><p><a href="http://static.oschina.net/uploads/img/201508/19145154_KFNY.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730162324" alt="Unnamed QQ Screenshot20150730162324" src="http://static.oschina.net/uploads/img/201508/19145157_AJrb.png" width="244" height="94"></a></p><p>此时我们可能看到浏览器通过端口16201与服务器连接，由于没有读写请求，由于浏览器会一直停留在连接状态等待超时</p><p>确定程序能正常运行我们再继续编码读写部分</p><p>一旦连接成功后我们可以通过连接成功的套接字temp这个对象来读取写</p><p>接收temp.Receive(buf, buf.Length, SocketFlags.None);</p><p>发送temp.Send(buf, buf.Length, SocketFlags.None);</p><p>其中需要先建立byte[] buf = new byte[1024];一个buf来存储</p><p>然后可以读写操作</p><p>读出来的buf可以通过Encoding.ASCII.GetString(buf, 0, bytes);转换成字符串来显示</p><p><a href="http://static.oschina.net/uploads/img/201508/19145206_vYAv.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730164753" alt="Unnamed QQ Screenshot20150730164753" src="http://static.oschina.net/uploads/img/201508/19145208_M9Ic.png" width="481" height="169"></a></p><p>我们先读取到buf，转换成string对象显示到控制台，再从控制台读取一行发送到远端，最后关闭连接，关闭监听</p><p>测试运行</p><p><a href="http://static.oschina.net/uploads/img/201508/19145211_y9AX.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730164930" alt="Unnamed QQ Screenshot20150730164930" src="http://static.oschina.net/uploads/img/201508/19145214_jdii.png" width="677" height="443"></a></p><p>浏览器发送http请求数据输入到服务器</p><p>然后我们写入一行</p><p><a href="http://static.oschina.net/uploads/img/201508/19145214_MNNo.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730165044" alt="Unnamed QQ Screenshot20150730165044" src="http://static.oschina.net/uploads/img/201508/19145215_NuBL.png" width="182" height="62"></a></p><p>回车</p><p><a href="http://static.oschina.net/uploads/img/201508/19145216_qg0n.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730165110" alt="Unnamed QQ Screenshot20150730165110" src="http://static.oschina.net/uploads/img/201508/19145218_NLWn.png" width="319" height="119"></a></p><p>浏览器显示hello world</p><p>虽然使用并不符合http规范的响应也可以被部分浏览器显示，但为了达到更规范的http服务器，我们需要写上相应的响应头</p><p>buf = Encoding.ASCII.GetBytes("HTTP/1.1 200 OK\r\nServer: HTTPServer\r\n\r\n&lt;h1&gt;" + Console.ReadLine().ToString()+"&lt;/h1&gt;");</p><p>不同的相应具有不同的响应头，这里不仔细研究更多的情况</p><p><a href="http://static.oschina.net/uploads/img/201508/19145220_KNkF.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150730170314" alt="Unnamed QQ Screenshot20150730170314" src="http://static.oschina.net/uploads/img/201508/19145222_WeNq.png" width="817" height="290"></a></p><p>最后我们可以通过chrome的开发者工具看到相关的相应信息，包括服务器与返回的状态码，也能正确读取具体的内容</p><p>通过这次实验掌握了socket的单线程编程，对于tcp连接的几个步骤也有更深刻的理解，对http的规范也有相应的掌握，在多线程与异步的处理上仍有待学习提高</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_494519" href="http://my.oschina.net/tmj1993/blog/494519">C#-JudgeSystem判题系统-安装和熟悉C#开发环境</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-08-19 13:54:41</div>
	  <div class='catalog'>分类：JudgeSystem判题系统</div>
	  	  	  <div class='tags'>标签：C#,Server,编译,多线程,判题系统</div>	  	  	  </div>
      <div class='content'><p>由于该项目属于已完成项目，过程实验报告均以提交，这里一次性提交到博客中分享一下</p><p><a href="http://static.oschina.net/uploads/img/201508/19141133_3c6y.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150819135319" alt="Unnamed QQ Screenshot20150819135319" src="http://static.oschina.net/uploads/img/201508/19141135_6DLv.png" width="905" height="329"></a></p><p><a href="http://static.oschina.net/uploads/img/201508/19141209_soFF.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729144235" alt="Unnamed QQ Screenshot20150729144235" src="http://static.oschina.net/uploads/img/201508/19141214_0xZA.png" width="955" height="582"></a></p><p>新建一个wpf项目，命名为HTTPServer</p><p><a href="http://static.oschina.net/uploads/img/201508/19141249_fafn.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729144620" alt="Unnamed QQ Screenshot20150729144620" src="http://static.oschina.net/uploads/img/201508/19141308_xfXO.png" width="231" height="257"></a></p><p>点击MainWindow.xaml可以进入xaml的设计器环境</p><p><a href="http://static.oschina.net/uploads/img/201508/19141322_lC0Z.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729144815" alt="Unnamed QQ Screenshot20150729144815" src="http://static.oschina.net/uploads/img/201508/19141326_u6wI.png" width="785" height="491"></a></p><p>在设计器环境中我们可以通过下方的xaml代码编辑器进行界面修改</p><p><a href="http://static.oschina.net/uploads/img/201508/19141328_eodT.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729144754" alt="Unnamed QQ Screenshot20150729144754" src="http://static.oschina.net/uploads/img/201508/19141330_QaXw.png" width="315" height="460"></a></p><p>也可以通过右侧工具箱拖拉控件调整位置</p><p><a href="http://static.oschina.net/uploads/img/201508/19141331_6be0.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729145202" alt="Unnamed QQ Screenshot20150729145202" src="http://static.oschina.net/uploads/img/201508/19141332_SPFo.png" width="417" height="284"></a></p><p>根据实验要求我们先拖放两个文本框</p><p>然后我们还需要添加两个多行文本框</p><p><a href="http://static.oschina.net/uploads/img/201508/19141333_Yd0q.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729145736" alt="Unnamed QQ Screenshot20150729145736" src="http://static.oschina.net/uploads/img/201508/19141334_h78y.png" width="419" height="289"></a></p><p>拖拉完成后我们需要进行对文本框的换行属性进行编辑</p><p>我们可以直接修改xaml或者在右侧控件属性中修改</p><p><a href="http://static.oschina.net/uploads/img/201508/19141335_Etl0.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729145931" alt="Unnamed QQ Screenshot20150729145931" src="http://static.oschina.net/uploads/img/201508/19141336_B6oE.png" width="295" height="560"></a></p><p>在属性框上方的搜索框中输入相关的可修改属性可以快速找到修改项</p><p>找到图中TextWrapping属性可以进行修改，wrap代表可换行，nowrap不换行</p><p><a href="http://static.oschina.net/uploads/img/201508/19141337_PwXY.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729150138" alt="Unnamed QQ Screenshot20150729150138" src="http://static.oschina.net/uploads/img/201508/19141338_oRxO.png" width="269" height="71"></a></p><p>而一些其他类型的属性可以按需求进行修改，增加enter换行等属性</p><p>除了通过图形界面进行拖拉勾选编辑，我们还可以直接编写xaml代码</p><p><a href="http://static.oschina.net/uploads/img/201508/19141339_B5lq.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729150455" alt="Unnamed QQ Screenshot20150729150455" src="http://static.oschina.net/uploads/img/201508/19141339_f6De.png" width="751" height="16"></a></p><p>与xml相似的格式，我们可以在一行中添加删除属性来修改textbox的属性，不存在的则以默认值来规约</p><p>比如上面修改换行属性我们可以直接添加TextWrapping="Wrap"，Wrap值可以修改</p><p>理解wpf中xaml的界面编辑方式，我们可以继续完成该实验，把控件全部写上并且调整好位置</p><p><a href="http://static.oschina.net/uploads/img/201508/19141402_Ydvp.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729151248" alt="Unnamed QQ Screenshot20150729151248" src="http://static.oschina.net/uploads/img/201508/19141415_sfVn.png" width="420" height="287"></a></p><p>固定好控件的分配，开始修改控件的默认显示，比如修改标题，label，以及textbox的默认文字显示</p><p>修改完成后初步完成界面的设计</p><p><a href="http://static.oschina.net/uploads/img/201508/19141417_tQfp.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729151624" alt="Unnamed QQ Screenshot20150729151624" src="http://static.oschina.net/uploads/img/201508/19141418_lTvn.png" width="417" height="284"></a></p><p>下一步开始处理控件的相应</p><p><a href="http://static.oschina.net/uploads/img/201508/19141422_9xfV.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729151837" alt="Unnamed QQ Screenshot20150729151837" src="http://static.oschina.net/uploads/img/201508/19141424_CbYT.png" width="319" height="301"></a></p><p>在属性中可以切换到事件相应的处理函数填写界面</p><p>其中我们需要给button控件增加一个click的相应</p><p><a href="http://static.oschina.net/uploads/img/201508/19141426_2tCZ.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729152135" alt="Unnamed QQ Screenshot20150729152135" src="http://static.oschina.net/uploads/img/201508/19141429_QUBN.png" width="314" height="230"></a></p><p>回车可以进入后台代码处理界面</p><p><a href="http://static.oschina.net/uploads/img/201508/19141430_Uy6z.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729152251" alt="Unnamed QQ Screenshot20150729152251" src="http://static.oschina.net/uploads/img/201508/19141431_VFuy.png" width="526" height="340"></a></p><p>只要点击按钮就会触发该函数</p><p>界面和响应逻辑处理好后，可以对相应函数的具体实现进行处理</p><p>要求将输入框内容复制到输出框</p><p>也时候我们需要拿到输入输出框的资源名称变量名进行控制</p><p><a href="http://static.oschina.net/uploads/img/201508/19141432_gqRN.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729152957" alt="Unnamed QQ Screenshot20150729152957" src="http://static.oschina.net/uploads/img/201508/19141433_PgKN.png" width="270" height="43"></a></p><p>添加两个x:Name</p><p>之后添加一行recv.Text = send.Text;即可实现复制</p><p><a href="http://static.oschina.net/uploads/img/201508/19141434_72PQ.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729153118" alt="Unnamed QQ Screenshot20150729153118" src="http://static.oschina.net/uploads/img/201508/19141435_ALB9.png" width="554" height="108"></a></p><p>接下可以运行程序进行测试</p><p><a href="http://static.oschina.net/uploads/img/201508/19141436_fPSB.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729153243" alt="Unnamed QQ Screenshot20150729153243" src="http://static.oschina.net/uploads/img/201508/19141436_2IOq.png" width="107" height="41"></a></p><p><a href="http://static.oschina.net/uploads/img/201508/19141438_1315.png" rel="nofollow"><img title="Unnamed QQ Screenshot20150729153431" alt="Unnamed QQ Screenshot20150729153431" src="http://static.oschina.net/uploads/img/201508/19141440_ict7.png" width="419" height="285"></a></p><p>在左侧输入文本，点击发送，右侧出现相同的内容，运行成功</p><p>多次输入测试，都可以正确运行</p><p>进行实验之前我已经使用过wpf开发相关的程序，所以过程并没有遇到什么问题，巩固基础知识与操作，为接下来的实验提供基础，以及配置好相关的运行环境</p></div>
	      </div>
        <div class='blog'>
      <h2><a href="#top" class='top'>回到顶部</a><a name="blog_494496" href="http://my.oschina.net/tmj1993/blog/494496">开始博客之旅</a></h2>
	  <div class='outline'>
	  <div class='date'>时间：2015-08-19 13:30:19</div>
	  <div class='catalog'>分类：杂谈</div>
	  	  	  	  	  </div>
      <div class='content'><p>自我介绍一下，虽然也没啥好自我介绍的，本来就想匿名的一个博客，2015年9月开始就是大四了，也要面临找实习呀工作呀等问题，然而在这个暑假我并没有去找什么实习。</p>  <p>我们老师说过，人生呀，起码还要工作40多年，这个暑假给你多工作一个多月又能有什么区别，还不如好好找个地方玩玩，毕竟未来数十年的时间，也许你都不会再有这么长的假期了。</p>  <p>于是我找实习，就是抱着能找就找，找不到就回家的心情去找的，结果果然还是很难，但回家还是有好处的，起码这也是这博客建立的初衷。</p>  <p>如果没多少经验，然后去找一家一般般的公司，还是说多点经验，然后去找一家好一点的公司，那个更好一点呢？</p>  <p>我还是比较看好后者，所以我选择回来自己做点东西。</p>  <p>至于为什么要写博客呢？有几个原因</p>  <p>1、笔记本</p>  <p>2、面试资本</p>  <p>3、人生积累</p>  <p>对于我而且最重要的是第二个吧，可是很快就要开学找实习了，反正慢慢来吧，先写点博客。</p>  <p>因为我做过什么根本没人知道，以至于面试的时候面试官还问我那些技能描述是不是抄网上一些就业技能的，这么一听我真是既开心又不开心，一个确实我会的还是有用的，另外一个人与人的信任真的没有呀，尤其在就业的时候，公司没必要去信任你，更重要的是自己证明自己，github上面的几个项目真的是你自己的吗？这也是会质疑的。</p>  <p>所以博客干嘛用，起码能证明这几个项目是我写的，过程都在。这就是这博客的最重要的用途。</p>  <p>至于博客，我真心不爱写，与其一堆文字证明自己，还不如自己好好提高一下编程技能。</p>  <p>不过不可以否认的是，写写博客以后就能当笔记本用，不用再百度啥的反复翻阅已经看过的内容。</p>  <p>有时候也会幻想这个博客要是写个几十年，回过头老会不会感叹，也许会的。</p></div>
	      </div>
      </div>
</body>
</html>
    